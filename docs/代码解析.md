# GeoData

## GeoData.h

**概括描述**：

`GeoData` 类用于管理几何数据，包括点、线、环、多边形等拓扑结构，并支持渲染、序列化和编辑操作。它继承自 `SketchObject` 和 `IRenderable`，提供对 `Nous` 网格 (`NMesh`) 的封装，实现了几何数据的存储、查询、操作以及可视化。

**详细描述**：

1. **基本结构**：
   - `GeoData` 继承自 `SketchObject` 和 `IRenderable`，既能作为通用的几何数据存储对象，也支持渲染接口。
   - 友元类：
     - `GeoDataUtils`：提供几何数据的工具方法。
     - `GeoDataTopoOperations`：用于拓扑相关操作，如合并、分割、校验等。

2. **数据管理**：
   - `m_nous_mesh`：存储 `Nous` 网格数据，提供点、线、多边形的几何信息。
   - `m_nous_position_handle`：用于访问 `Nous` 网格的点坐标数据。
   - `m_key_lines` / `m_key_rings` / `m_ring_adj_polygons`：分别存储 `SketchLine`、`SketchRing` 和 `RingPolygonRelation`，用于管理线、环、多边形之间的拓扑关系。
   - `m_nousptr_points` / `m_nousptr_lines` / `m_nousptr_rings`：存储 `Nous` 数据结构到 `Sketch` 数据结构的映射。

3. **渲染与标记**：
   - `update_render_mesh()`：检查 `m_dirty_flags` 是否需要更新渲染资源，并调用 `_update_render_resource()` 进行更新。
   - `mark_render_mesh_as_dirty()` / `mark_mesh_as_dirty()` / `mark_all_sketch_polygon_dirty()`：用于标记几何数据的更新状态。

4. **数据操作**：
   - **查询**：
     - `get_all_polygons()` / `get_all_lines()` / `get_point_adj_points()` / `get_point_adj_rings()` / `get_point_adj_lines()`：提供点、线、环、多边形的查询操作。
     - `is_valid()`：判断几何元素是否有效。
     - `is_line()`：判断 `Nous` 基元是否为线。
   - **添加**：
     - `add_point()` / `add_point_without_check()`：添加点。
     - `add_line()` / `add_line_without_check()`：添加线，支持拓扑更新或直接插入。
     - `add_polygon()` / `add_polygon_without_check()`：添加多边形，支持检查拓扑结构。
     - `add_element_group()`：添加元素组（如 `NoBranchLineGroup`）。
   - **删除**：
     - `delete_line()` / `delete_lines()`：删除线，并处理拓扑合并。
     - `delete_polygon()`：删除多边形，支持级联删除无效的线。
     - `delete_element_group()`：删除元素组。

5. **序列化**：
   - `save(SketchSerializer& serializer)`：将 `GeoData` 数据保存到 `SketchSerializer`。
   - `load(SketchSerializer& serializer)`：从 `SketchSerializer` 加载 `GeoData` 数据。

6. **内部实现（受保护方法）**：
   - `_sync_nous()`：同步 `Nous` 网格数据。
   - `_add_nous_line()` / `_delete_nous_line()`：内部方法，用于管理 `Nous` 线。
   - `_add_nous_ring()` / `_delete_nous_ring()`：内部方法，用于管理 `Nous` 环。
   - `_check_ring_affilia_and_create_polygon()` / `_create_polygon()` / `_delete_polygon()`：管理多边形创建、删除和拓扑检查。
   - `_trangulate_sketch_polygon()`：对 `SketchPolygon` 进行三角剖分，用于渲染。

7. **静态工具方法**：
   - `line_key()` / `ring_key()`：计算 `SketchLine` 和 `SketchRing` 的唯一键，便于索引。

**核心逻辑**：

该类的核心功能是 **管理 `Nous` 网格数据，维护几何拓扑结构，并提供渲染、序列化、查询、增删改等操作，以支持复杂的几何编辑和可视化**。

## GeoData.cpp

### GeoData

**概括描述**：

该代码是 `GeoData` 类的拷贝构造函数，主要用于从 `other` 复制所有的几何数据，包括点、线、环、多边形及其拓扑关系，并重新建立它们之间的关联。它首先创建一个新的 `nous::NMesh` 网格并复制 `other` 的数据，然后依次复制点、线、环、多边形及元素组，最后标记所有数据为脏，使其后续可以正确更新。

**详细描述**：

构造函数首先调用 `SketchObject` 的基类构造函数，并指定类型为 `ESketchObjectType::GeoData`，然后创建一个新的 `nous::NMesh` 实例，并获取其点位置属性句柄 `m_nous_position_handle`，用于后续操作。接着，通过 `m_nous_mesh->copy(other.m_nous_mesh.get());` 复制 `other` 的网格数据，使 `m_nous_mesh` 具有相同的几何结构。

在复制点的过程中，代码遍历 `m_nous_mesh` 的所有点，使用 `m_nousptr_points[point] = std::make_shared<SketchPoint>(point);` 为每个点创建 `SketchPoint` 对象，并存入 `m_nousptr_points`，这样在后续构建拓扑结构时能够正确关联点对象。

复制线数据时，代码遍历 `other.m_key_lines`，获取 `nous::Prim*` 关联的 `SketchLine`，然后查找该线的两个端点，计算 `line_key`，创建新的 `SketchLine`，并存入 `m_key_lines` 和 `m_nousptr_lines`，确保线的拓扑关系保持一致。

对于环，代码遍历 `other.m_key_rings`，获取 `nous::Prim*` 关联的 `SketchRing`，然后遍历 `nous::prim_vertices_range(ring_prim->idx())` 获取环上的所有点，计算 `ring_key`，创建新的 `SketchRing`，并存入 `m_key_rings` 和 `m_nousptr_rings`，从而复制环的几何信息。

在复制多边形及其拓扑关系时，代码遍历 `other.m_ring_adj_polygons`。对于每个环，如果 `polygon` 存在，则在 `m_ring_adj_polygons` 中查找该 `ring`，如果还未被关联，则创建 `SketchPolygon` 并进行关联，同时复制 `inner_rings` 并建立父子关系。如果 `parent_polygon` 存在，则查找其 `ring`，同样创建 `SketchPolygon` 并建立父子关系，以保证多边形的层次结构与 `other` 保持一致。

最后，代码处理元素组的复制。它遍历 `other.m_ele_groups`，如果是 `NoBranchLineGroup` 类型，则创建新的 `NoBranchLineGroup`，并遍历其中的 `SketchLine`，找到对应的 `SketchLine` 并加入 `m_ele_groups`，从而复制该元素组的拓扑结构。但对于 `SmoothGroup`，相关逻辑尚未实现，可能需要后续补充。

在完成所有数据复制后，构造函数将 `m_dirty_flags` 设置为 `0xffffffff`，标记所有数据为脏，使 `GeoData` 在后续更新过程中能够正确同步新的几何数据和拓扑关系。

### dispose

**概括描述**：

`dispose()` 方法用于清理 `GeoData` 对象的所有数据，并标记为脏（dirty），确保后续需要重新计算和更新几何数据。

**详细描述**：

首先，`m_dirty_flags = 0xffffffff;` 这一行代码将 `m_dirty_flags` 设置为 `0xffffffff`，即所有标志位都被置为 1，表示 `GeoData` 的所有数据都需要更新。接着，调用 `this->clear();` 方法，该方法的作用是清空 `GeoData` 的所有数据结构，包括网格、关键点、关键线、关键环、多边形关系等，同时同步 `nous` 网格数据，使当前对象处于一个完全清理的状态。这样，`dispose()` 方法的整体作用就是 **将 `GeoData` 置于一个清空并等待重新初始化的状态**。

### get_all_polygons

**概括描述**：

`get_all_polygons()` 方法用于获取 `GeoData` 中所有的 `SketchPolygon` 对象，包括直接关联的多边形和其父多边形，并将它们存入 `std::unordered_set` 进行返回。

**详细描述**：

首先，声明 `std::unordered_set<SketchPolygonPtr> result;` 作为存储所有 `SketchPolygon` 对象的集合。然后，遍历 `m_ring_adj_polygons`，它是一个 `std::unordered_map<SketchRingPtr, RingPolygonRelation>`，其中每个 `RingPolygonRelation` 可能包含一个 `polygon`（当前环对应的多边形）和一个 `parent_polygon`（父多边形）。如果 `polygon` 存在，则将其插入 `result`，保证所有环对应的多边形都被收集。如果 `parent_polygon` 存在，也同样插入 `result`，确保所有父多边形也被包含在返回结果中。最后，返回 `result`，即 `GeoData` 中所有的 `SketchPolygon` 对象集合。

### is_line

**概括描述**：

`is_line()` 方法用于判断给定的 `nous::Prim*` 是否表示一条有效的线（Polyline）。

**详细描述**：

首先，检查 `prim` 是否为非空指针，避免空指针访问错误。然后，判断 `prim->type()` 是否为 `nous::PrimType::Polyline`，确保该 `Prim` 是一条折线（Polyline）。接着，检查 `prim->num_vertices() == 2`，确保该 `Polyline` 仅由两个顶点组成，即它是一条单独的线段，而不是更复杂的折线。最后，调用 `prim->is_valid()`，确保该 `Prim` 是有效的。如果所有条件都满足，则返回 `true`，否则返回 `false`。该方法的作用是 **判断 `prim` 是否为合法的线段**。

### get_line_adj_rings

**概括描述**：

`get_line_adj_rings()` 方法用于获取与指定 `SketchLine` 共享边的所有 `SketchRing`，即查找该线段所在的所有闭合环。

**详细描述**：

首先，声明 `std::unordered_set<SketchRingPtr> result;` 用于存储与 `line` 相邻的所有 `SketchRing`。然后，遍历 `m_nous_mesh->point_vertices_range(line->p0->point->idx())`，即 `line->p0` 这个点关联的所有 `Vertex`，获取每个 `Vertex` 的 `next_vertex_ptr()` 和 `pre_vertex_ptr()`，判断它们是否指向 `line->p1->point->idx()`，如果是，则说明该 `Vertex` 连接了 `line` 的两个端点。接着，检查 `point_vertex->prim_ptr()` 是否为非线 `Prim`（即 `is_line()` 返回 `false`），如果是，则说明该 `Prim` 是一个 `SketchRing`，将其加入 `result`。

然后，对 `line->p1` 进行相同的处理，遍历 `m_nous_mesh->point_vertices_range(line->p1->point->idx())`，寻找与 `line->p0` 连接的 `Vertex`，并检查它们所属的 `Prim` 是否是环。如果符合条件，则将其存入 `result`。

最终，返回 `result`，即 `line` 所属的所有 `SketchRing` 集合。该方法的核心逻辑是 **遍历 `line` 的两个端点，查找所有与 `line` 共享边但不是线段的 `Prim`，从而获取 `line` 所在的所有环**。

### get_ring_adj_lines

**概括描述**：

`get_ring_adj_lines()` 方法用于获取与指定 `SketchRing` 相邻的所有 `SketchLine`，即组成该环的所有边。

**详细描述**：

首先，声明 `std::unordered_set<SketchLinePtr> result;` 用于存储环 `ring_prim` 关联的所有 `SketchLine`。然后，调用 `get_element_points(ring_prim)` 获取该环的所有顶点，并存入 `std::vector<SketchPointPtr> topo`。

接下来，遍历 `topo` 中的点，逐对处理相邻点 `(topo[i], topo[i + 1])`，计算它们的哈希键 `lk = line_key(topo[i], topo[(i + 1) % topo.size()])`。其中 `(i + 1) % topo.size()` 采用取模运算，以确保最后一个点能够与第一个点相连，形成闭合环。

然后，检查 `lk` 是否存在于 `m_key_lines`，即该边是否在 `GeoData` 的线集合中。如果存在，则将其加入 `result`，确保所有构成 `ring_prim` 的 `SketchLine` 都被正确收集。

最终，返回 `result`，即该 `SketchRing` 关联的所有 `SketchLine` 集合。该方法的核心逻辑是 **遍历环的所有点对，计算边的唯一标识，并从 `m_key_lines` 中查找对应的线对象**。

### get_point_adj_points

**概括描述**：

`get_point_adj_points()` 方法用于获取与指定 `SketchPoint` 相邻的所有 `SketchPoint`，即直接连接到该点的所有点。

**详细描述**：

首先，声明 `std::unordered_set<SketchPointPtr> result;` 作为存储相邻点的集合，并检查 `point->point->vertex_ptr()` 是否为空指针。如果为空，则说明该点没有关联的 `Vertex`，直接返回空集合。

然后，遍历 `m_nous_mesh->point_neighbours_range(point->point->idx())`，它返回 `point` 关联的所有相邻点的索引 `pt_idx`。对于每个 `pt_idx`，通过 `m_nous_mesh->point(pt_idx)` 获取对应的 `nous::Point*`，再通过 `m_nousptr_points.at(...)` 查找 `SketchPointPtr`，如果 `adj_pt` 存在，则将其插入 `result`，保证所有相邻点都被正确收集。

最终，返回 `result`，即 `point` 直接相邻的 `SketchPoint` 集合。该方法的核心逻辑是 **通过 `m_nous_mesh` 查找 `point` 的邻居索引，并映射到 `SketchPointPtr`，确保所有邻接点都被正确获取**。

### add_point

**概括描述**：

`add_point()` 方法用于向 `GeoData` 添加一个新的点。如果该点已经存在，则返回已存在的 `SketchPoint`，否则调用 `add_point_without_check(pos)` 添加新点。

**详细描述**：

首先，遍历 `m_nous_mesh->point_index_range()`，即 `m_nous_mesh` 中的所有点索引 `pt_idx`。然后，通过 `m_nous_position_handle.get(pt_idx)` 获取索引 `pt_idx` 处的点的坐标 `exist_pt_pos`。

接着，调用 `sketch_math::point_equal(pos, exist_pt_pos)` 判断 `pos` 是否与 `exist_pt_pos` 相等，如果相等，则说明该点已存在，直接从 `m_nousptr_points` 中获取对应的 `SketchPointPtr` 并返回。

如果遍历完所有点都未找到相同坐标的点，则调用 `add_point_without_check(pos)` 创建新点并返回。该方法的核心逻辑是 **先检查 `pos` 是否已存在，如果已存在则复用，否则创建新点**，从而避免重复添加相同的点。

### add_point_without_check

**概括描述**：

`add_point_without_check()` 方法直接向 `GeoData` 添加一个新的 `SketchPoint`，而不进行去重检查。

**详细描述**：

首先，调用 `m_nous_mesh->add_point(pos)` 在 `m_nous_mesh` 中添加一个新的 `nous::Point`，并使用 `m_nous_mesh->point(...)` 获取该点的指针 `np`。然后，使用 `std::make_shared<SketchPoint>(np)` 创建一个新的 `SketchPointPtr`，并存入 `m_nousptr_points[np]`，建立 `nous::Point*` 到 `SketchPointPtr` 的映射关系。最后，返回新创建的 `SketchPointPtr`。

该方法的核心逻辑是 **直接在 `m_nous_mesh` 中添加点，并创建对应的 `SketchPointPtr`，不进行任何去重检查**，因此它通常被 `add_point()` 作为辅助方法调用。

### add_line

**概括描述**：

`add_line()` 方法用于在 `GeoData` 中添加一条新线段 `(p0, p1)`，并根据拓扑结构处理相关的线段拆分、焊接组调整和多边形生成（若 `genPolygon` 为 `true`）。

**详细描述**：

首先，声明 `new_lines` 用于存储新添加的线段，并调用 `_add_line(p0, p1, recreat_line, new_line_points)` 计算 `p0` 和 `p1` 之间的连线，同时返回受影响的旧线段 `recreat_line`，以及新创建的点 `new_line_points`。然后，遍历 `recreat_line`，调用 `GeoDataTopoOperations::get().replace_line(this, rl.first, rl.second);` 替换被拆分的旧线段，确保拓扑结构一致。

接着，检查 `new_line_points` 中的每个点，遍历其相邻线段 `get_point_adj_lines(point)`，如果相邻线段属于 `NoBranchLineGroup`，则调用 `add_force_separate_point(point)` 强制断开该点，并设置 `group->set_need_check(true);`，以确保拓扑调整后能正确分组。

然后，遍历 `new_line_points`，依次连接相邻点，调用 `_add_nous_line(new_line_points[i], new_line_points[i - 1])` 添加新线段，并存入 `new_lines`。同时，调用 `GeoDataTopoOperations::get().check_path_and_split_sketch_polygon(this, cl);` 检查该线段是否导致多边形需要拆分。

如果 `genPolygon` 为 `true`，则进行多边形构造。首先，定义 `ring_contain_target_part()`，用于检查 `target` 线段是否位于 `ring` 内部。然后，调用 `_sync_nous()` 以确保 `m_nous_position_handle` 处于最新状态，并计算 `base_dir` 作为 `p0` 到 `p1` 方向的单位向量，初始化 `path`、`normal` 和 `dir`，并调用 `_find_coplain_rings()` 查找所有与 `cl` 线段共面的环 `coplane_rings`。

遍历 `coplane_rings`，如果两个环重叠，则使用 `ring_contain_target_part()` 选择保留的环。随后，遍历所有共面环，检查环是否已存在于 `m_key_rings`，如果不存在，则调用 `add_polygon()` 创建新多边形；如果已存在但未关联多边形，也调用 `add_polygon()` 进行关联，确保拓扑关系完整。

最后，设置 `m_dirty_flags |= 0x1;` 和 `m_dirty_flags |= 0x2;`，标记 `GeoData` 需要重新更新渲染和同步 `Nous` 数据，并返回 `new_lines`，即新添加的线段列表。该方法的核心逻辑是 **添加线段、拆分受影响的线段、调整拓扑结构，并根据需要创建多边形**。

### add_line_without_check

**概括描述**：

`add_line_without_check()` 方法用于直接在 `GeoData` 中添加一条连接 `p0` 和 `p1` 的线段，而不进行任何检查。

**详细描述**：

该方法直接调用 `_add_nous_line(p0, p1)` 来创建一条 `SketchLine`，并将其返回。它不会检查 `p0` 和 `p1` 是否已经被其他线段连接，也不会处理可能的拓扑变化。因此，它通常作为底层辅助方法使用，在调用它之前，调用者需要确保 `p0` 和 `p1` 之间确实需要添加新线段，并且不会影响拓扑结构。

### delete_line

**概括描述**：

`delete_line()` 方法用于删除 `GeoData` 中的一条 `SketchLine`，并根据参数决定是否合并相邻线段和多边形，同时处理因删除线段而变得无效的点。

**详细描述**：

首先，方法调用 `get_line_adj_rings(line)` 获取 `line` 关联的所有 `SketchRing`，存入 `line_adj_rings`。然后，遍历 `line_adj_rings`，查找共面的环：

- 若 `ring1` 已经被处理，则跳过。
- 获取 `ring1` 的法向量 `ring1_normal`，然后遍历 `line_adj_rings` 查找另一个法向量平行的 `ring2`，如果找到，则将 `(ring1, ring2)` 作为共面环对存入 `coplane_ring`，否则 `ring1` 独立存入 `coplane_ring`。

完成共面环查找后，调用 `GeoDataTopoOperations::get().merge_coplane_ring_and_polygon()` 处理共面环合并，若 `merge_adj_polygon` 为 `true`，则合并相邻多边形。

接下来，删除 `line`，首先记录 `p0` 和 `p1`，然后调用 `_delete_nous_line(line)` 实际删除 `line`。如果 `merge_adj_line` 为 `true`，则检查 `p0` 和 `p1` 是否可以合并相邻线段：

- 若 `force_keeped_point_set` 为空，或 `p0` 不在 `force_keeped_point_set` 中，则调用 `GeoDataTopoOperations::get().check_point_and_merge_line(this, p0, force_keeped_point_set);` 进行点合并。
- `p1` 也进行相同的检查和处理。

然后，检查 `p0` 和 `p1` 是否仍然与 `Vertex` 关联：

- 若 `p0->point->vertex_ptr()` 为空，表示 `p0` 已不再属于任何拓扑结构，则从 `m_nousptr_points` 中移除，并调用 `m_nous_mesh->delete_point(p0->point->idx())` 删除该点。
- 对 `p1` 进行相同的处理。

最后，设置 `m_dirty_flags |= 0x1;` 和 `m_dirty_flags |= 0x2;`，标记 `GeoData` 需要更新渲染和同步 `Nous` 数据。该方法的核心逻辑是 **删除线段，并根据需要合并相邻线段和多边形，同时移除已变得无效的点**。

### delete_lines

**概括描述**：

`delete_lines()` 方法用于批量删除 `GeoData` 中的一组 `SketchLine`，并根据参数决定是否合并相邻线段和环结构。

**详细描述**：

首先，声明 `std::unordered_set<SketchPointPtr> points;` 用于存储所有被删除线段的端点。然后，遍历 `lines` 集合，对于每条 `line`，将其两个端点 `p0` 和 `p1` 插入 `points`，并调用 `delete_line(line, false, mergeAdjRing);` 删除该线段。注意这里的 `mergeAdjLine` 参数被设置为 `false`，意味着单独删除每条线段时不会立即合并相邻线段，而是先将所有线段删除后再统一处理。

如果 `mergeAdjLine` 为 `true`，则遍历 `points` 集合，调用 `GeoDataTopoOperations::get().check_point_and_merge_line(this, p);`，检查每个点是否可以合并相邻线段，确保拓扑结构的完整性。

该方法的核心逻辑是 **先批量删除线段，记录所有受影响的端点，然后根据需要合并相邻线段，以保证拓扑结构的正确性**。

### add_polygon

> `std::vector<std::vector<SketchPointPtr>> GeoData::add_polygon(const std::vector<std::vector<nous::pos_t>>& polygon_pos)`

**概括描述**：

`add_polygon()` 方法用于根据输入的多边形顶点坐标 `polygon_pos` 在 `GeoData` 中创建一个新的 `SketchPolygon`，并保证点、线、环的拓扑结构正确。

**详细描述**：

首先，声明 `recreat_line_points` 用于存储所有新创建的点，并初始化 `polygon_pt_arr`，用于存储新的多边形拓扑结构。然后，遍历 `polygon_pos` 中的每个环 `ring`，对 `ring` 内的点进行处理：

- 声明 `ring_pt_arr` 并添加到 `polygon_pt_arr`，用于存储该环的 `SketchPointPtr`。
- 遍历 `ring` 的点，依次取相邻的点对 `(p0, p1)`，调用 `_add_line(p0, p1, recreat_line, new_line_points)` 创建线段，返回受影响的旧线段 `recreat_line` 和新创建的 `new_line_points`。
- 遍历 `recreat_line`，调用 `GeoDataTopoOperations::get().replace_line(this, rl.first, rl.second);` 替换被拆分的旧线段，确保拓扑结构一致。
- 遍历 `new_line_points`，检查其相邻线段 `get_point_adj_lines(point)`，如果相邻线段属于 `NoBranchLineGroup`，则调用 `add_force_separate_point(point)` 强制断开，并标记 `set_need_check(true)` 以确保拓扑调整后能正确分组。
- 如果 `new_line_points` 不为空，则遍历 `new_line_points` 并依次连接相邻点，调用 `_add_nous_line(new_line_points[i], new_line_points[i + 1])` 添加新线段，并将点存入 `ring_pt_arr` 和 `recreat_line_points`。

在所有环处理完毕后，调用 `sketch_math::ring_normal(polygon_pos[0])` 计算多边形的法向量 `normal`，然后调用 `this->add_polygon(polygon_pt_arr, normal);` 创建 `SketchPolygon`。最后，返回 `polygon_pt_arr`，即新创建的多边形的点集合。

该方法的核心逻辑是 **依次创建多边形的点和线，保证拓扑结构完整，并在必要时处理焊接组的拓扑调整**。

### add_polygon

> `void GeoData::add_polygon(const std::vector<std::vector<SketchPointPtr>>& polygon, nous::vec3 normal)`

**概括描述**：

`add_polygon()` 方法用于向 `GeoData` 添加一个新的 `SketchPolygon`，并确保其与现有的多边形拓扑结构正确融合。它会检测新多边形是否与已有的多边形共面，处理相交部分，并拆分或合并内环，以保证拓扑完整性。

**详细描述**：

首先，声明 `coplane_polygons` 和 `coplane_rings`，用于存储与新多边形共面的现有多边形和环。然后，获取 `polygon` 的第一个点 `pos`，遍历所有已有的多边形 `get_all_polygons()`，检查它们的法向量 `ring_normal` 与新多边形的法向量 `normal` 是否共面（`sketch_math::plane_coplane_plane()`）。如果共面，则将该多边形及其所有环（外环 `ring` 和内环 `inner_rings`）加入 `coplane_polygons` 和 `coplane_rings`。

然后，调用 `geodata_topo::split_intersect_polygons()`，计算新多边形与共面多边形的相交情况，并拆分 `polygon` 以适应现有拓扑。`recreate_polygons` 存储需要被拆分的旧多边形的替代结构，`new_polygons` 存储完全新的多边形。

接下来，为了处理 `geos` 生成的内环联合体，代码缓存所有共面环 `coplane_rings` 的拓扑数据到 `coplane_rings_topo`，并定义 `split_polygon_inner_ring()` 函数，用于拆分新生成的多边形的内环。该函数会检查 `polygon` 的内环是否在 `coplane_rings_topo` 中：

- 如果内环不存在于 `coplane_rings_topo`，说明它可能是多个已存在的环的组合，则查找所有包含该内环的环，删除被包含的环，并调用 `geodata_topo::ring_difference_other_rings()` 计算新环。
- 如果内环已经存在，则直接将其加入 `result_polygon` 并从 `coplane_rings_topo` 中移除，确保它不会作为其他环的子环。

然后，遍历 `recreate_polygons`，对需要拆分的多边形执行 `split_polygon_inner_ring()`，并调用 `GeoDataTopoOperations::get().replace_polygon()` 替换原来的多边形。

最后，遍历 `new_polygons`，对所有新的多边形执行 `split_polygon_inner_ring()` 处理内环，并调用 `add_polygon_without_check()` 添加到 `GeoData`。

该方法的核心逻辑是 **检测新多边形的共面多边形，处理相交区域，拆分或合并内环，并更新 `GeoData` 的拓扑结构**。

### add_polygon_without_check

> `std::vector<std::vector<SketchPointPtr>> GeoData::add_polygon_without_check(const std::vector<std::vector<nous::pos_t>>& polygon_pos, const bool add_line)`

**概括描述**：

`add_polygon_without_check()` 方法用于在 `GeoData` 中添加一个新的 `SketchPolygon`，但不检查其是否与现有多边形相交或重复。它会直接创建点，并调用另一个 `add_polygon_without_check()` 方法完成最终的多边形构造。

**详细描述**：

首先，声明 `polygon_pt_arr`，用于存储新多边形的点结构。然后，遍历 `polygon_pos` 中的每个环 `ring`，依次处理环内的点：

- 为 `ring` 创建一个新的 `ring_pt_arr` 并添加到 `polygon_pt_arr`。
- 遍历 `ring` 中的每个点 `pos`，调用 `add_point_without_check(pos)` 直接创建 `SketchPointPtr`，并将其存入 `ring_pt_arr`。

处理完所有点后，调用 `add_polygon_without_check(polygon_pt_arr, add_line)`，将 `polygon_pt_arr` 作为输入，完成多边形的最终添加。最后，返回 `polygon_pt_arr`，即新建多边形的点集合。

该方法的核心逻辑是 **将输入的点坐标转换为 `SketchPointPtr`，然后调用底层方法完成多边形创建，而不进行拓扑检查**。

### add_polygon_without_check

> `SketchPolygonPtr GeoData::add_polygon_without_check(const std::vector<std::vector<SketchPointPtr>>& polygon, bool add_line)`

**概括描述**：

`add_polygon_without_check()` 方法用于在 `GeoData` 中直接添加一个新的 `SketchPolygon`，不会进行任何拓扑检查。如果 `add_line` 为 `true`，它会确保多边形的边界线存在，并最终调用 `_create_polygon()` 创建 `SketchPolygon` 对象。

**详细描述**：

首先，检查 `add_line` 是否为 `true`，如果是，则遍历 `polygon` 的每个环 `ring_pts`，并在其中遍历所有点 `ring_pts[i]`，将当前点 `prev_pt` 与下一个点 `next_pt` 连接成线段。`(i + 1) % ring_pts.size()` 采用取模运算，确保最后一个点能够正确连接到第一个点，形成闭合环。调用 `add_line_without_check(prev_pt, next_pt);` 直接添加线段，而不进行任何拓扑检查。

处理完所有边界线后，调用 `_create_polygon(polygon);` 创建 `SketchPolygon`，并返回该对象。

该方法的核心逻辑是 **在不进行拓扑验证的情况下直接创建 `SketchPolygon`，并可选地创建边界线，以保证多边形具有完整的结构**。

### delete_polygon

**概括描述**：

`delete_polygon()` 方法用于删除 `GeoData` 中的 `SketchPolygon`，如果 `need_delete_line` 为 `true`，则同时检查并删除该多边形的所有边界线段，并确保拓扑结构保持一致。

**详细描述**：

首先，声明 `std::unordered_set<SketchLinePtr> line_set;` 用于存储需要删除的线段。如果 `need_delete_line` 为 `true`，则先处理多边形的外环 `polygon->ring`：

- 调用 `get_element_points(polygon->ring, exring_pt_arr);` 获取外环的点序列。
- 遍历 `exring_pt_arr`，计算相邻点之间的 `line_key`，并从 `m_key_lines` 获取对应的 `SketchLinePtr`，加入 `line_set`。

然后，遍历 `polygon->inner_rings`（内环），执行相同的操作，将内环的边界线存入 `line_set`，确保所有环的线段都被正确记录。

接着，调用 `_delete_polygon(polygon);` 删除 `polygon` 及其关联的拓扑信息。

如果 `need_delete_line` 为 `true`，则遍历 `line_set`，检查每条线是否仍然被其他环使用：

- 如果 `get_line_adj_rings(line).empty()` 返回 `true`，说明该线段不再被任何环使用，调用 `delete_line(line, true, true, force_keeped_point_set);` 直接删除该线段，并根据拓扑情况合并相邻线段。
- 如果 `line` 仍然被环使用，则调用 `GeoDataTopoOperations::get().check_point_and_merge_line(this, p0, force_keeped_point_set);` 和 `GeoDataTopoOperations::get().check_point_and_merge_line(this, p1, force_keeped_point_set);`，检查 `p0` 和 `p1` 是否可以与相邻线段合并，以保持拓扑结构完整。

最后，设置 `m_dirty_flags |= 0x1;` 和 `m_dirty_flags |= 0x2;`，标记 `GeoData` 需要更新渲染和同步 `Nous` 数据。该方法的核心逻辑是 **删除 `polygon`，根据需要删除线段，并检查拓扑结构是否需要合并或调整**。

### add_element_group

**概括描述**：

`add_element_group()` 方法用于向 `GeoData` 中添加一个新的元素组（`ElementGroupPtr`）。

**详细描述**：

该方法直接调用 `m_ele_groups.insert(group);`，将 `group` 插入到 `m_ele_groups` 集合中，以便 `GeoData` 维护对该元素组的管理。由于 `m_ele_groups` 是一个 `std::unordered_set<ElementGroupPtr>`，它能够自动确保元素组不会重复添加。该方法的核心逻辑是 **将 `group` 添加到 `GeoData` 的元素组集合中，以支持分组管理**。

### delete_element_group

**概括描述**：

`delete_element_group()` 方法用于从 `GeoData` 中删除指定的元素组（`ElementGroupPtr`），并解除其包含元素的组关系。

**详细描述**：

首先，遍历 `group->elements()`，即该组中的所有元素，并调用 `ele->set_group(nullptr);` 将每个元素的组指针设置为空，以解除它们与 `group` 的关联。然后，调用 `m_ele_groups.erase(group);` 从 `m_ele_groups` 集合中移除 `group`，彻底删除该元素组的管理。

该方法的核心逻辑是 **先解除所有成员元素的组绑定，再从 `GeoData` 的元素组集合中移除 `group`，确保拓扑关系一致**。

### _add_line

**概括描述**：

`_add_line()` 方法用于在 `GeoData` 中添加一条新的线段 `(lp0, lp1)`，并确保拓扑结构正确。它会检测 `lp0` 和 `lp1` 之间是否已有相同或相交的线段，并进行拆分或合并，以维护拓扑一致性。新生成的点存入 `new_line_points`，而需要重建的线段存入 `recreat_lines`。

**详细描述**：

首先，调用 `_sync_nous()` 以确保 `m_nous_position_handle` 处于最新状态。然后，定义三个 Lambda 函数：

- `lessThan(v1, v2)`: 比较两个点的坐标，按照 `(x, y, z)` 递增排序。
- `swapV3(v1, v2)`: 交换两个 `nous::vec3` 变量的值。
- `equalV3(v1, v2)`: 判断两个点是否足够接近（平方距离小于 `epsilon`）。

然后，声明两个 `std::map` 结构：

- `_new_line_point`：存储新线段的端点及其对应的 `SketchPointPtr`（如果已存在）。
- `_recreat_line_point`：存储需要拆分的线段及其新的拆分点。

如果 `lp0` 和 `lp1` 非法（相等），则直接返回。否则，使用 `lessThan()` 规范化 `p0` 和 `p1` 的顺序，确保 `p0` 的坐标始终小于 `p1`。计算线段 `p0p1` 的方向向量 `u`，并初始化 `_new_line_point`，将 `p0` 和 `p1` 作为起点和终点。

然后，遍历 `m_key_lines` 中所有已有线段 `line`，检查 `line` 的两个端点 `p2` 和 `p3`：

- 规范化 `p2` 和 `p3` 的顺序。
- 如果 `p0p1` 和 `p2p3` 是完全相同的线段，则直接返回。
- 如果 `p0p1` 与 `p2p3` 平行，则进一步判断是否相交或重叠，并适当拆分 `line`。
- 如果 `p0p1` 与 `p2p3` 相交，则计算交点 `p0x` 并拆分 `line`，将交点加入 `_new_line_point` 和 `_recreat_line_point`。

遍历 `_new_line_point`，依次创建 `SketchPoint`：

- 如果某个点 `it->second.second` 为空，则说明该点尚未存在，需要在 `m_nous_mesh` 中创建新点并存入 `m_nousptr_points`。
- 将点按顺序存入 `new_line_points`，如果之前交换了 `p0` 和 `p1`，则需要反向排序。

遍历 `_recreat_line_point`，将所有拆分出的新点存入 `recreat_lines`，确保需要重新创建的线段能正确重建。

该方法的核心逻辑是 **在 `GeoData` 中添加一条新线段，检查是否需要拆分已有线段，并确保拓扑结构的一致性**。

### _delete_nous_line

**概括描述**：

`_delete_nous_line()` 方法用于删除 `GeoData` 中的 `SketchLine`，包括从 `m_key_lines` 中移除该线，并在 `Nous` 网格中删除对应的 `Prim`。

**详细描述**：

首先，检查 `line` 是否属于某个 `group()`（元素组），如果是，则调用 `group()->erase_element(line);` 将其从组中移除，确保 `group` 结构的完整性。

然后，调用 `m_nous_mesh->delete_prim(line->line_prim->idx(), false);` 删除 `Nous` 网格中的 `Prim`，但参数 `false` 可能表示不会触发自动更新或合并操作，具体行为取决于 `Nous` 的实现。

接着，调用 `m_key_lines.erase(line->key);` 从 `m_key_lines` 中移除该线段的记录，确保 `GeoData` 不再维护这条线。

最后，设置 `m_dirty_flags |= 0x1;` 和 `m_dirty_flags |= 0x2;`，标记 `GeoData` 需要更新渲染和同步 `Nous` 数据。

该方法的核心逻辑是 **确保 `SketchLine` 被从 `GeoData` 和 `Nous` 网格中完全移除，并正确更新拓扑结构**。

### _add_nous_ring

**概括描述**：

`_add_nous_ring()` 方法用于在 `GeoData` 中添加一个新的 `SketchRing`，如果该环已存在，则直接返回已有的 `SketchRing`，否则创建新环并更新拓扑结构。

**详细描述**：

首先，调用 `GeoData::ring_key(topo)` 计算 `topo`（环上的点列表）的唯一键值 `ring_key`，用于标识该环。然后，在 `m_key_rings` 中查找该 `ring_key` 是否已存在：

- 如果 `ring_key` 存在，则直接返回 `m_key_rings[ring_key]`，避免重复创建相同的环。
- 如果 `ring_key` 不存在，则创建 `nous::Array<nous::Point*> n_topo`，并将 `topo` 中的 `SketchPointPtr` 转换为 `nous::Point*`，存入 `n_topo`。
- 调用 `m_nous_mesh->add_prim(n_topo, nous::PrimType::Polygon);` 创建一个 `nous::Prim*`，表示该环作为 `Polygon` 存入 `Nous` 网格，并获取其索引。

然后，使用 `std::make_shared<SketchRing>(new_prim, ring_key)` 创建 `SketchRingPtr`，并计算其法向量：

- 调用 `GeoDataUtils::get().get_ring_positions(this, new_ring);` 获取 `new_ring` 的点坐标。
- 调用 `sketch_math::ring_normal(vp);` 计算 `new_ring->normal`，确保法向量正确。

最后，将新创建的 `SketchRingPtr` 存入 `m_key_rings[ring_key]` 和 `m_nousptr_rings[new_prim]`，确保 `GeoData` 维护该环的拓扑信息。同时，设置 `m_dirty_flags |= 0x1;` 和 `m_dirty_flags |= 0x2;`，标记 `GeoData` 需要更新渲染和同步 `Nous` 数据，并返回新创建的 `SketchRingPtr`。

该方法的核心逻辑是 **检查是否已存在该环，若不存在则创建新 `SketchRing` 并存入 `m_key_rings`，确保拓扑结构完整**。

### _delete_nous_ring

**概括描述**：

`_delete_nous_ring()` 方法用于删除 `GeoData` 中的 `SketchRing`，并确保其关联的多边形和拓扑关系得到正确维护。如果该环属于某个 `SketchPolygon`，则会处理其父多边形关系，并删除无用的内环。

**详细描述**：

首先，从 `m_ring_adj_polygons` 中获取 `ring` 关联的 `parent_polygon`（父多边形）和 `polygon`（自身所属的多边形）。如果 `parent_polygon` 存在，则从 `parent_polygon->inner_rings` 中移除 `ring`，并标记 `parent_polygon->m_changed = true;`，表示其拓扑结构发生了变化。

然后，检查 `polygon` 是否存在：

- 遍历 `polygon->inner_rings`，将其所有内环的 `parent_polygon` 设置为 `parent_polygon`，确保拓扑层级保持正确。
- 如果 `parent_polygon` 存在，则将 `polygon->inner_rings` 重新添加到 `parent_polygon->inner_rings` 中，确保层级结构的完整性。
- 如果 `parent_polygon` 不存在，并且某个 `inner_ring` 没有关联的 `polygon`，则将其加入 `need_delete` 集合，表示这些内环可以被删除。
- 遍历 `need_delete`，递归调用 `_delete_nous_ring(inner_ring);` 逐步删除这些环。

接着，删除 `ring` 及其在 `GeoData` 中的所有关联记录：

- 调用 `get_element_points(ring);` 获取环上的所有点，并计算 `GeoData::ring_key(topo);`，然后从 `m_key_rings` 中移除该环。
- 从 `m_nousptr_rings` 和 `m_ring_adj_polygons` 中删除 `ring` 的记录，确保 `GeoData` 结构保持一致。
- 调用 `m_nous_mesh->delete_prim(ring->ring_prim->idx(), false);` 从 `Nous` 网格中删除该环的 `Prim`。

最后，设置 `m_dirty_flags |= 0x1;` 和 `m_dirty_flags |= 0x2;`，标记 `GeoData` 需要更新渲染和同步 `Nous` 数据。

该方法的核心逻辑是 **删除 `SketchRing`，同时维护其关联的多边形和内环结构，确保 `GeoData` 的拓扑关系保持正确**。

### _find_coplain_rings

**概括描述**：

`_find_coplain_rings()` 方法用于在 `GeoData` 中搜索共面的环（`SketchRing`）。它使用递归深度优先搜索（DFS）查找从 `current` 点到 `end` 点的所有共面路径，并存入 `result`。

**详细描述**：

首先，调用 `_sync_nous()` 确保 `m_nous_position_handle` 数据最新，并定义 `dot_epsilon`（0.001）用于浮点数比较精度。如果 `current == end`，则说明找到了一条完整的路径：

- 遍历 `result`，检查 `normal.back()` 是否与已存路径的法向量 `plan.first` 共面（点积接近 1）。
- 如果是，则将 `path` 添加到该共面组，否则创建一个新的共面组并存入 `result`。
- 终止当前递归。

然后，遍历 `current` 点的所有相邻点 `neighbor`，过滤出尚未访问的点，并计算 `neighbor` 与 `current` 形成的方向向量 `bc`，计算 `k = -bc.dot(ab) / ab.dot(ab)`（`k` 表示 `neighbor` 在线段 `ab` 上的投影因子），按 `k` 升序存入 `validNeighbor`，确保搜索顺序稳定。

如果 `normal.back()` 接近零（即初始法向量未定义），则需要计算所有可能的法向量，并建立 `validPlan`：

- 遍历 `validNeighbor`，计算 `neighbor` 的方向向量 `cdir`，并求出与 `dir.back()` 的叉积 `planNormal`，得到潜在的共面法向量。
- 根据 `cdir` 与现有 `plan.first` 的关系，决定是否合并到已有平面组或创建新平面组。

然后，选择合适的 `neighbor` 继续搜索：

- 如果 `validPlan` 为空，则创建一个默认的 180° 平面路径。
- 选取 `plan.second` 中最小角度和最大角度的 `neighbor`，存入 `validPoint`，然后递归调用 `_find_coplain_rings()` 进行进一步搜索。
- 递归返回后，回溯 `normal` 和 `dir`，并从 `visited` 中移除 `neighbor`，确保搜索不会进入死循环。

如果 `normal.back()` 已经定义，则直接使用 `anglePoint` 记录所有符合法向量的邻居，并按角度选择合适的 `neighbor` 递归搜索。

该方法的核心逻辑是 **使用 DFS 搜索共面的环，确保所有路径保持拓扑一致，并正确分类共面拓扑结构**。

### _find_split_ring_path

**概括描述**：

`_find_split_ring_path()` 方法用于在 `GeoData` 中查找将 `SketchRing` 拆分的路径。它使用深度优先搜索（DFS）从 `cpos` 开始，沿着与 `normal` 垂直的方向查找一条连接到 `ring` 的路径，并将路径存入 `result`。

**详细描述**：

首先，调用 `_sync_nous()` 以确保 `m_nous_position_handle` 处于最新状态，并定义 `dot_epsilon = 1e-3f` 作为浮点数精度阈值。然后，检查 `cpos` 是否已访问，若未访问，则将其添加到 `path` 并继续搜索。

遍历 `m_nous_mesh->point_prims_range(cpos->point->idx())`，检查 `cpos` 是否属于 `ring`：

- 如果 `ring->ring_prim->idx() == i`，说明 `cpos` 连接到 `ring`，将当前 `path` 赋值给 `result` 并终止搜索。

然后，将 `cpos` 标记为已访问，并遍历 `get_point_adj_points(cpos)` 获取其所有邻接点 `neighbor`：

- 如果 `neighbor` 已经访问过，则跳过，避免重复搜索。
- 计算 `cpos` 到 `neighbor` 的方向向量 `uDir`，并计算其与 `normal` 的点积 `dp`。
- 如果 `std::abs(dp) < dot_epsilon`，说明 `uDir` 与 `normal` 垂直，即 `neighbor` 在与 `normal` 共面的方向上，可以继续搜索。

递归调用 `_find_split_ring_path(neighbor, ring, visited, normal, path, result)` 继续向 `neighbor` 扩展搜索：

- 如果 `result` 不为空，说明找到了路径，立即返回。

如果所有邻居都搜索完毕且未找到 `ring`，则回溯，将 `cpos` 从 `path` 中移除，继续其他搜索路径。

该方法的核心逻辑是 **使用 DFS 沿着与 `normal` 垂直的方向查找 `cpos` 到 `ring` 的连接路径，并确保搜索过程中避免重复访问**。

### _check_ring_affilia_and_create_polygon

**概括描述**：

`_check_ring_affilia_and_create_polygon()` 方法用于检查一个 `SketchRing` 是否已经存在，并建立其与其他 `SketchRing` 及 `SketchPolygon` 的拓扑关系。如果该环 `ring` 已经存在，则直接返回；如果不存在，则创建一个新的 `SketchRing`，并根据 `gen_polygon` 选项决定是否创建 `SketchPolygon`，同时调整其父子关系，确保拓扑结构正确。

**详细描述**：

首先，初始化 `contained`（存储包含当前 `ring` 的外环）和 `contains`（存储当前 `ring` 包含的内环集合）。然后，检查 `ring` 是否已存在于 `m_key_rings`，如果已存在，则直接返回已存的 `SketchRingPtr`，避免重复创建。

如果 `ring` 不存在，则调用 `GeoDataUtils::get().get_ring_relation_rings(this, ring, contained, contains);` 获取当前 `ring` 的拓扑关系：

- `contained` 记录包含 `ring` 的最近的外环（如果有）。
- `contains` 记录所有被 `ring` 包含的内环（如果有）。

若 `contains` 或 `contained` 非空，则打印调试信息（可能是用于开发阶段的检查）。

然后，调用 `_add_nous_ring(ring);` 创建新的 `SketchRingPtr` 并存入 `new_ring`，如果 `gen_polygon` 为 `true`，则调用 `_create_polygon(new_ring, {})` 创建 `SketchPolygonPtr`，并存入 `new_skp`。

如果 `contained` 不为空，且 `m_ring_adj_polygons[contained].polygon` 存在，则：

- 将 `new_ring` 添加到 `contained` 的 `inner_rings` 集合中，
- 标记 `m_ring_adj_polygons[contained].polygon->m_changed = true;`，表示其拓扑结构发生变化，
- 设定 `m_ring_adj_polygons[new_ring].parent_polygon = m_ring_adj_polygons[contained].polygon;`，即 `new_ring` 归属于 `contained`。

然后，遍历 `contains`（当前 `ring` 所包含的内环）：

- 获取 `inner_ring` 的拓扑关系（`GeoDataUtils::get().get_ring_relation_rings(this, inner_ring, inner_ring_contained, inner_ring_contains);`）。
- 如果 `inner_ring_contained != new_skp->ring`，说明该内环不应归属于 `new_skp`，跳过。
- 若 `contained` 存在，且 `m_ring_adj_polygons[contained].polygon` 也存在，则将 `inner_ring` 从 `contained` 的 `inner_rings` 中移除。
- 设定 `m_ring_adj_polygons[inner_ring].parent_polygon = new_skp;`，并将 `inner_ring` 添加到 `new_skp->inner_rings`，调整拓扑关系。

然后，调用 `GeoDataTopoOperations::get().verify_sketch_polygon(this, new_skp, false);` 以验证新创建的多边形是否符合拓扑要求。

如果 `verify_parent` 为 `true`，且 `contained` 存在，则对 `m_ring_adj_polygons[contained].polygon` 再次执行 `verify_sketch_polygon()`，确保其拓扑结构完整性。

最后，设置 `m_dirty_flags |= 0x1;` 和 `m_dirty_flags |= 0x2;`，标记 `GeoData` 需要更新渲染和同步 `Nous` 数据，并返回新创建的 `SketchRingPtr`。

该方法的主要作用是 **检查 `ring` 是否已存在，若不存在则创建，并自动调整它的拓扑关系，使其正确归属于包含它的 `SketchPolygon`，并管理 `inner_rings` 关系，确保 `GeoData` 的拓扑结构完整**。

### _create_polygon

**概括描述**：

`_create_polygon()` 方法用于在 `GeoData` 中创建一个新的 `SketchPolygon`，并确保其外环和内环正确关联。

**详细描述**：

首先，调用 `_add_nous_ring(ring[0])` 创建 `main_ring`，它代表多边形的外环。然后，初始化 `inner_ring` 作为 `std::unordered_set<SketchRingPtr>`，用于存储多边形的内环。

遍历 `ring` 的其余部分（索引 `1` 开始），对于每个 `ring[i]`，调用 `_add_nous_ring(ring[i])` 创建 `SketchRingPtr` 并插入 `inner_ring`，确保所有内环都正确添加。

最后，调用 `_create_polygon(main_ring, inner_ring)`，以 `main_ring` 作为外环，`inner_ring` 作为内环，创建 `SketchPolygonPtr`，并返回该多边形对象。

**核心逻辑**：

该方法的主要作用是 **创建一个新的 `SketchPolygon`，确保外环 `main_ring` 和所有 `inner_ring` 结构正确添加，并调用 `_create_polygon(main_ring, inner_ring)` 进行最终的多边形创建**。

### _create_polygon

**概括描述**：

`_create_polygon()` 方法用于创建一个新的 `SketchPolygon`，并确保其外环、内环和拓扑关系正确存储在 `GeoData` 中，同时更新 `Nous` 网格中的法向量属性。

**详细描述**：

首先，调用 `std::make_shared<SketchPolygon>(ring)` 创建 `SketchPolygonPtr new_skp`，并将 `ring->normal` 赋值给 `new_skp->normal`，确保新多边形继承外环的法向量。同时，将 `inner_rings` 赋值给 `new_skp->inner_rings`，确保所有内环正确关联。

接着，遍历 `inner_rings`，将每个 `inner_ring` 的 `parent_polygon` 设为 `new_skp`，即这些内环属于新创建的 `SketchPolygon`，并存入 `m_ring_adj_polygons` 以维护拓扑关系。

然后，在 `Nous` 网格中创建或获取法向量属性 `nous::ATTRIB_NAME_NORMAL`，并使用 `attr_handle.set(ring->ring_prim->idx(), ring->normal);` 将 `ring->normal` 存入 `Nous` 数据结构中，以便渲染时正确显示法向量。

接着，在 `m_ring_adj_polygons` 中查找 `ring` 是否已有关联数据：

- 如果 `ring` 不在 `m_ring_adj_polygons` 中，则创建新记录 `{ new_skp, nullptr }`，表示 `ring` 作为新多边形的外环，并且没有上级多边形。
- 不管是否已有记录，都确保 `m_ring_adj_polygons[ring].polygon` 指向 `new_skp`，并同步存储法向量。

最后，设置 `m_dirty_flags |= 0x1;` 和 `m_dirty_flags |= 0x2;`，标记 `GeoData` 需要更新渲染和同步 `Nous` 数据，并返回 `new_skp`。

**核心逻辑**：

该方法的主要作用是 **创建 `SketchPolygon`，确保外环 `ring`、内环 `inner_rings` 以及拓扑关系正确存储，同时更新 `Nous` 网格中的法向量信息**。

### _delete_polygon

**概括描述**：

`_delete_polygon()` 方法用于删除 `GeoData` 中的 `SketchPolygon`，并正确处理其关联的内环和外环，确保拓扑关系的完整性。

**详细描述**：

首先，遍历 `polygon->inner_rings`，依次处理每个 `inner_ring`：将 `m_ring_adj_polygons[inner_ring].parent_polygon` 设为 `nullptr`，解除其父多边形关系。如果 `inner_ring` 没有对应的 `polygon`（即它不是其他多边形的外环），则调用 `_delete_nous_ring(inner_ring);` 删除该环。清空 `polygon->inner_rings`，确保该多边形不再持有任何内环。

然后，获取 `polygon` 的外环 `ring`，将 `m_ring_adj_polygons[ring].polygon` 设为 `nullptr`，表示该环不再归属于任何 `SketchPolygon`。

如果 `ring` 仍然有 `parent_polygon`，说明它是某个 `SketchPolygon` 的内环，因此不能删除，直接 `return`。否则，调用 `_delete_nous_ring(ring);`，彻底删除 `ring`，保证 `GeoData` 拓扑结构的完整性。

**核心逻辑**：

该方法的主要作用是 **删除 `SketchPolygon`，确保所有内环的父级关系被正确解除，并在合适的情况下删除无用的 `SketchRing`，避免拓扑残留**。

### _trangulate_sketch_polygon

**概括描述**：

`_trangulate_sketch_polygon()` 方法用于对 `SketchPolygon` 进行三角剖分（Triangulation），即将多边形划分为一系列三角形，以便用于渲染或其他几何计算。如果初次剖分失败，它会尝试修复无效的拓扑结构，并重新执行三角剖分。

**详细描述**：

首先，调用 `vp->triangles.clear();` 清空 `vp` 之前存储的三角形数据，确保重新剖分时不会受到旧数据的影响。

接着，检查 `vp` 是否有 `ring`，如果有，则调用 `geodata_topo::triangulate_polygon_cdt(this, vp);` 使用 **约束性 `Delaunay` 三角剖分（CDT）** 进行多边形剖分。

如果 `vp->triangles.size() == 0`，说明 `CDT` 失败，即生成的三角形数量为零，则执行错误修复策略：

1. 获取当前多边形的点坐标数据：
   - 调用 `GeoDataUtils::get().get_polygon_positions(this, vp);` 获取 `vp` 多边形的坐标点集合，存入 `polygon_point_pos`。
2. 修复无效的多边形拓扑：
   - 调用 `topo::rebuild_invalid_polygon_topo(polygon_point_pos);` 尝试修复 `polygon_point_pos` 可能存在的拓扑问题，并返回 `splited_valid_polygon`，即经过修复后的多个子多边形。
3. 对修复后的多边形执行三角剖分：
   - 遍历 `splited_valid_polygon`，逐个对子多边形调用 `geodata_topo::triangulate_polygon(splited_valid_polygon[i]);` 进行三角剖分。
   - 遍历 `triangles`，将 `triangles[j]` 转换为 `SketchPolygonTriangle`，并存入 `vp->triangles`，确保 `vp` 仍然能够正确存储三角形数据，即使最初的 `CDT` 失败。

**核心逻辑**：

该方法的主要作用是 **对 `SketchPolygon` 进行三角剖分，以便后续渲染或计算。如果 `CDT` 失败，它会尝试修复拓扑错误并重新执行剖分，确保 `vp` 始终能获得正确的三角形数据**。

### _update_render_resource

**概括描述**：

`_update_render_resource()` 方法用于更新 `GeoData` 的渲染资源，包括多边形和线段的顶点、法向量、颜色、UV 坐标以及索引数据，以便正确地进行 3D 渲染。

**详细描述**：

1. **同步 `Nous` 数据并清空渲染资源**：
   - 调用 `_sync_nous()` 确保 `m_nous_position_handle` 数据最新。
   - 调用 `IRenderable::clear()` 清空之前的渲染数据，防止数据混乱。

2. **初始化渲染数据容器**：
   - 定义 `polygon_submesh` 和 `line_submesh`，用于存储多边形和线段的索引数据。
   - 获取用于渲染的各种数据数组，如 `position`（顶点位置）、`normal`（法向量）、`color`（颜色）、`uv`（纹理坐标）、`lines_index`（线段索引）、`triangles_index`（三角形索引）、`submeshes`（子网格信息）。
   - `mesh_point_vertex_map` 用于存储 `SketchPointPtr` 到渲染网格顶点索引的映射。

3. **处理多边形数据**：
   - 计算 `base_point_size`，用于基准点索引计算。
   - 遍历 `m_ring_adj_polygons`，处理所有 `SketchPolygon`：
     - **检查是否需要重新计算三角剖分**：
       - 计算 `skp` 的法向量，并计算其旋转到 XY 平面的变换 `rotate_to_xy_plane`。
       - 如果 `skp->m_changed` 为 `true`，调用 `_trangulate_sketch_polygon(skp);` 重新计算三角剖分，并清除 `m_changed` 标志。
     - **遍历 `skp->triangles`，填充顶点和索引数据**：
       - 通过 `fill_tri()` 处理三角形顶点：
         - 获取 `point.first` 对应的 `nous::pos_t` 坐标，并存入 `position`、`normal`、`uv` 等渲染数据。
         - 如果点未存入 `prim_point_vertex_map`，则存入 `mesh_point_vertex_map`，避免重复添加。
         - `rotate_to_xy_plane` 计算该点在 XY 平面的 UV 坐标。
       - 计算 `t1, t2, t3`（三角形顶点索引），存入 `added_triangles`。

4. **处理线段数据**：
   - 遍历 `m_key_lines`，为 `SketchLine` 生成渲染顶点：
     - 通过 `point_valid_vertex()` 确保 `line->p0` 和 `line->p1` 的位置已添加到 `position` 数组，并返回索引。
     - 存入 `line_submesh` 以供后续渲染。

5. **更新 `submeshes` 结构**：
   - 遍历 `polygon_submesh`，创建 `SubmeshData`，存储 `Triangles`（三角形拓扑）信息，并填充 `triangles_index`。
   - 遍历 `line_submesh`，创建 `SubmeshData`，存储 `Lines`（线段拓扑）信息，并填充 `lines_index`。

6. **返回 `true`，表示更新完成**。

**核心逻辑**：

该方法的主要作用是 **同步 `GeoData` 的渲染数据，确保所有多边形和线段的拓扑关系正确，并填充渲染所需的顶点、法向量、颜色、UV 和索引数据，以支持正确的 3D 可视化**。

### save

**概括描述**：

`save()` 方法用于将 `GeoData` 的数据以二进制格式序列化并存储到 `SketchSerializer`，包括 `Nous` 网格数据、多边形信息以及无分支线组（weld line group）的拓扑结构。

**详细描述**：

1. **保存 `Nous` 网格数据**：
   - 定义 `mesh_binary_buffer` 作为存储 `Nous` 网格的二进制缓冲区。
   - 调用 `m_nous_mesh->save_binary(mesh_binary_buffer);` 将网格数据转换为二进制格式。
   - 通过 `serializer.write_binary(mesh_binary_buffer, "nous_mesh");` 将该缓冲区写入 `serializer`，并标记为 `"nous_mesh"`。

2. **保存多边形数据**：
   - 开始写入 `polygons` 数组：`serializer.begin_write_array("polygons");`。
   - 遍历 `m_ring_adj_polygons` 中的每个多边形：
     - 如果 `polygon.second.polygon == nullptr`，跳过该多边形。
     - 开始写入对象 `serializer.begin_write_object();`。
     - 记录该多边形的法向量 `serializer.advance_write(polygon.first->normal, "normal");`。
     - 记录 `ring` 的索引 `serializer.write(polygon.first->ring_prim->idx(), "ring_idx");`。
     - 开始写入内环索引数组 `serializer.begin_write_array("inner_ring_idxs");`：
       - 遍历 `polygon.second.polygon->inner_rings`，将 `ring_prim` 的索引写入 `"idx"`。
     - 结束内环索引数组 `serializer.end_write_array();`。
     - 结束多边形对象 `serializer.end_write_object();`。
   - 结束多边形数组 `serializer.end_write_array();`。

3. **保存无分支线组（weld line group）**：
   - 开始写入 `no_branch_line_group` 数组：`serializer.begin_write_array("no_branch_line_group");`。
   - 遍历 `m_ele_groups`，检查其类型是否为 `EElementType::NoBranchLineGroup`：
     - 开始写入对象 `serializer.begin_write_object();`。
     - 开始写入 `"weld_lines"` 数组 `serializer.begin_write_array("weld_lines");`：
       - 遍历 `group->elements()`，获取 `line_prim` 的索引并写入 `"idx"`。
     - 结束 `weld_lines` 数组 `serializer.end_write_array();`。
     - 结束对象 `serializer.end_write_object();`。
   - 结束 `no_branch_line_group` 数组 `serializer.end_write_array();`。

**核心逻辑**：

该方法的主要作用是 **将 `GeoData` 的 `Nous` 网格数据、多边形拓扑结构以及无分支线组信息转换为二进制格式，并存储到 `SketchSerializer` 以便后续加载**。

### load

**概括描述**：

`load()` 方法用于从 `SketchSerializer` 中加载 `GeoData` 数据，包括 `Nous` 网格、多边形信息以及无分支线组（weld line group），并恢复 `GeoData` 的拓扑结构和关联关系。

**详细描述**：

1. **加载 `Nous` 网格数据**：
   - 定义 `mesh_binary_buffer` 作为存储 `Nous` 网格的二进制缓冲区。
   - 通过 `serializer.read_binary(mesh_binary_buffer, "nous_mesh");` 读取 `Nous` 网格的二进制数据。
   - 调用 `m_nous_mesh->load_binary(mesh_binary_buffer);` 解析并加载网格数据。

2. **恢复点数据**：
   - 通过 `m_nous_mesh->num_points();` 获取点的总数。
   - 遍历所有点：
     - 调用 `m_nous_mesh->point(i);` 获取 `Nous` 点对象。
     - 使用 `std::make_shared<SketchPoint>(point);` 创建 `SketchPointPtr` 并存入 `m_nousptr_points`。

3. **恢复线段与环数据**：
   - 通过 `m_nous_mesh->num_prims();` 获取 `Nous` 中的几何基元（`Prim`）总数。
   - 遍历所有 `Prim`：
     - 如果 `current_prim` 是一条线（`is_line(current_prim)` 返回 `true`），则：
       - 获取 `p0` 和 `p1`，计算唯一键 `lk = line_key(...)`。
       - 使用 `std::make_shared<SketchLine>(current_prim, lk);` 创建 `SketchLinePtr`，并存入 `m_key_lines` 和 `m_nousptr_lines`。
     - 如果 `current_prim` 是环，则：
       - 遍历 `current_prim` 的所有顶点，获取 `ring_points`。
       - 计算 `ring_key = GeoData::ring_key(ring_points);`，并创建 `SketchRingPtr`，存入 `m_key_rings` 和 `m_nousptr_rings`。

4. **加载多边形数据**：
   - 读取 `"polygons"` 数组：
     - 遍历每个多边形：
       - 读取 `normal` 和 `ring_idx`（环索引）。
       - 通过 `m_nous_mesh->prim(ring_idx);` 获取 `ring_prim`，然后找到对应的 `SketchRingPtr`。
       - 创建 `SketchPolygonPtr polygon = std::make_shared<SketchPolygon>(ring);`，并存入 `m_ring_adj_polygons`。
       - 读取 `"inner_ring_idxs"` 数组，恢复内环：
         - 遍历所有内环索引，找到 `SketchRingPtr` 并添加到 `polygon->inner_rings`。
         - 设置 `m_ring_adj_polygons[inner_ring].parent_polygon = polygon;` 以建立父子关系。

5. **加载无分支线组（weld line group）**：
   - 读取 `"no_branch_line_group"` 数组：
     - 遍历每个组：
       - 创建 `NoBranchLineGroupPtr group` 并存入 `m_ele_groups`。
       - 读取 `"weld_lines"` 数组，遍历所有线索引：
         - 通过 `m_nous_mesh->prim(line_idx);` 获取 `line_prim`，然后找到 `SketchLinePtr`。
         - 使用 `group->add_element(line);` 恢复组内线段的拓扑关系。

**核心逻辑**：

该方法的主要作用是 **从 `SketchSerializer` 中加载 `GeoData`，恢复 `Nous` 网格数据、线段、环和多边形的拓扑结构，并正确建立 `weld line group` 以确保数据完整**。

# Controller_Extrude_Polygon

## Controller_Extrude_Polygon.h

**概括描述**：

`Controller_Extrude_ByNormal` 继承自 `Controller_Edit`，用于处理基于法向方向的多边形拉伸操作。它支持拾取多边形、计算偏移、生成拉伸几何，并提供多种拉伸模式（添加/移动）以修改 `GeoData` 的拓扑结构。

**详细描述**：

1. **继承关系**：
   - 继承自 `Controller_Edit`，是一个几何编辑控制器。
   - 负责管理和操作 `GeoData` 中的多边形挤出（Extrude）操作。

2. **基本功能**：
   - **激活/禁用**：
     - `active()` / `deactive()`：激活或禁用该控制器。
   - **交互控制**：
     - `escape()` / `enter()`：进入或退出挤出模式。
     - `key_down()` / `mouse_down()` / `mouse_move()` / `mouse_up()`：处理键盘和鼠标输入。
   - **渲染相关**：
     - `prepare_render(View* view)`：准备渲染所需的数据。

3. **核心挤出操作**：
   - `processPickPolygon(GeoData* picked_geo, SketchRingPtr ring)`：处理用户选中的多边形，并准备后续的拉伸操作。
   - `switchMesh()`：切换当前编辑的网格，可能涉及保存旧网格或创建新网格。

4. **拉伸模式（Extrude Modes）**：
   - `create_add_operation_mesh(double offset)`：创建新的几何体用于添加模式的拉伸操作。
   - `create_move_operation_mesh(double offset)`：创建用于移动模式的拉伸几何。
   - `commit_extrude_mesh()`：应用挤出操作，更新 `GeoData`。

5. **拓扑计算**：
   - `get_valid_coplane_rings()`：获取共面的环，用于计算拓扑关系。
   - `get_offseted_polygon_positions()` / `offset_ring_positions()`：计算多边形/环的偏移位置，确保挤出过程中的几何正确性。
   - `need_flip_picked_normal()`：判断是否需要翻转拾取的法向量，以决定挤出方向。

6. **渲染推测**：
   - `prepare_add_mode_inferring_mesh()`：准备添加模式的推测网格数据。
   - `prepare_move_mode_inferring_mesh()`：准备移动模式的推测网格数据。

7. **缓存管理**：
   - `clear_all_cache_mesh_doc()` / `clear_inferring_mesh_doc()` / `clear_limits()` / `fix_inferring_mesh_doc()`：清理并修复推测网格数据，防止数据错误或残留。

8. **私有工具方法**：
   - `_process_select_info()`：处理选中信息。
   - `_create_nurbs_operation_mesh()` / `_generate_algebra_surface_operation_mesh()` / `_generate_closed_surface_operation_mesh()` / `_generate_complex_surface_operation_mesh()`：用于生成基于 NURBS 的挤出网格。
   - `_rollback_to_pick_element()`：撤回到选取元素状态，可能用于撤销操作。

9. **内部状态管理**：
   - **挤出模式**：
     - `ESketchExtrudeMode`（`ADD` / `MOVE`）：当前的拉伸模式。
   - **挤出步骤**：
     - `ESketchExtrudeStep`（`PICK_ELEMENT` / `EXTRUDE_BEGIN_FIXING` / `EXTRUDE_FIXING`）：当前的挤出状态。
   - **几何缓存**：
     - `m_pick_mesh_doc`：当前选中的网格文档。
     - `m_pick_polygon_normal`：选中多边形的法向量。
     - `m_extrude_polygon_begin_position`：拉伸起点。
     - `m_hover_pos`：鼠标悬停位置。
   - **拓扑结构**：
     - `m_selected_polygon_topo` / `m_new_add_polygon_topo_arr` / `m_new_move_polygon_topo_arr`：存储原始选中多边形及其新的拓扑数据。
     - `m_new_add_polygon_topo` / `m_new_move_polygon_topo`：存储新增/移动模式的点集合。
   - **NURBS 支持**：
     - `m_pick_nurbs_doc` / `m_selected_algebra_surface` / `m_selected_closed_surface` / `m_selected_complex_surface`：用于支持基于 NURBS 的挤出操作。
   - **挤出方向约束**：
     - `m_valid_move_dir`（`Both` / `Positive` / `Negative` / `None`）：定义当前方向上的移动约束。
   - **挤出范围限制**：
     - `m_negative_offset_limit` / `m_positive_offset_limit`：挤出移动的最小/最大偏移限制。

**核心逻辑**：

该类的核心功能是 **提供多边形的法向拉伸（Extrude）操作，支持添加和移动模式，并结合 `GeoData` 进行拓扑计算、网格更新和渲染推测，确保挤出操作的正确性和可视化**。

## Controller_Extrude_Polygon.cpp

### info

**概括描述**：

`info()` 方法用于获取当前 `Controller_Extrude_ByNormal` 控制器的参数信息，并返回 `SketchParamMap`，用于向外部提供当前控制器的状态。

**详细描述**：

1. **创建参数映射**：
   - 定义 `SketchParamMap para;` 作为存储参数的对象。

2. **设置参数**：
   - `para.set_value("current_param", "distance");`：表示当前控制器主要参数为 `distance`（即挤出距离）。
   - `para.set_value("name", m_name);`：存储当前控制器的名称。
   - `para.set_value("value", m_current_value);`：存储当前的数值参数，通常用于表示挤出的偏移量。

3. **返回参数映射**：
   - 返回 `SketchParamMap`，允许其他组件查询当前 `Controller_Extrude_ByNormal` 的状态。

**核心逻辑**：

该方法的主要作用是 **提供当前挤出控制器的关键信息，包括参数名称 (`distance`)、控制器名称 (`m_name`)、当前值 (`m_current_value`)，便于外部访问和 UI 显示**。

### active

**概括描述**：

`active()` 方法用于激活 `Controller_Extrude_ByNormal` 控制器，初始化交互提示、鼠标样式、推理系统，并检查当前选中的元素是否符合挤出条件。

**详细描述**：

1. **调用基类方法**：
   - 通过 `Controller_Edit::active(props);` 继承并执行 `Controller_Edit` 的 `active()` 方法，确保基本激活逻辑得以执行。

2. **初始化用户交互**：
   - `this->set_tip(L"select one face to extrude.");`：设置提示信息，引导用户选择一个面进行挤出。
   - `this->set_cursor(Define::CURSOR_CROSS);`：更改鼠标指针样式为十字形 (`CURSOR_CROSS`)，表明当前处于选择模式。

3. **设置推理系统**：
   - 获取当前聚焦的 `View`，然后获取 `InferenceHelper`（推理助手）。
   - `infer_helper->set_infer_filter_type(InferType::POLYGON);`：设置推理系统的筛选类型为 `POLYGON`，即只允许选择多边形。
   - `infer_helper->clear_refer();`：清除推理系统中的参考对象。

4. **确定当前挤出步骤**：
   - `m_extrude_step = ESketchExtrudeStep::PICK_ELEMENT;`：初始化 `m_extrude_step`，默认设为 `PICK_ELEMENT`，表示等待用户选择要挤出的元素。
   - 获取当前 `View` 选择器 (`view->selector()`) 的 `select_info`，检查选中元素：
     - 如果当前仅选中 **一个** 元素，且该元素类型为 `Polygon` 或 `AlgebraSurface`，则直接跳转到 `EXTRUDE_BEGIN_FIXING` 步骤。
   - 若未能直接进入 `EXTRUDE_BEGIN_FIXING`，则清除选区 `view->selector()->clear();`。

5. **确保 `NousEngine` 初始化**：
   - 通过 `NousEngine::is_inited()` 判断 `NousEngine` 是否已初始化。
   - 如果尚未初始化，则调用 `NousEngine::instance()->init();` 进行初始化。

**核心逻辑**：

该方法的主要作用是 **在激活挤出控制器时，初始化提示信息、鼠标样式、推理系统，并检查当前选中的元素是否符合挤出条件，如果符合则进入 `EXTRUDE_BEGIN_FIXING` 步骤，否则等待用户选择合适的元素**。

### deactive

**概括描述**：

`deactive()` 方法用于停用 `Controller_Extrude_ByNormal` 控制器，并调用基类 `Controller_Edit::deactive()` 进行默认的停用处理。

**详细描述**：

1. **调用基类方法**：
   - `Controller_Edit::deactive();` 负责执行 `Controller_Edit` 类中的 `deactive()` 方法，确保编辑控制器的停用逻辑得以执行。
   - 这可能包括：清理当前选择的几何元素、关闭推理系统、复位鼠标指针样式、取消任何激活的编辑模式。
   
2. **无额外操作**：
   - 该方法未对 `Controller_Extrude_ByNormal` 进行额外的清理，因此完全依赖基类 `deactive()` 的实现。

**核心逻辑**：

该方法的主要作用是 **停用 `Controller_Extrude_ByNormal` 控制器，并委托 `Controller_Edit` 进行必要的清理和状态恢复**。

### escape

**概括描述**：

`escape()` 方法用于处理用户按下 **Escape** 键的行为，根据当前的挤出状态 (`m_extrude_step`)，决定是回滚到选取元素状态还是直接停用控制器。

**详细描述**：

1. **调用基类方法**：
   - `Controller_Main::escape(props);` 先调用基类的 `escape()` 方法，确保基本的退出逻辑得以执行。
   
2. **判断当前挤出状态**：
   - `if(m_extrude_step == ESketchExtrudeStep::EXTRUDE_FIXING)`：
     - 如果当前处于 **EXTRUDE_FIXING**（正在执行挤出固定），则调用 `_rollback_to_pick_element()`，回滚到选取状态，可能是为了撤销当前操作并允许用户重新选择要挤出的元素。
   - `else`：
     - 否则，调用 `this->deactive();` 停用控制器，意味着直接退出挤出模式。

**核心逻辑**：

该方法的主要作用是 **当用户按下 Escape 键时，根据当前的挤出状态选择回滚到选取元素状态 (`_rollback_to_pick_element()`)，或者完全退出挤出模式 (`deactive()`)**。

### enter

**概括描述**：

`enter()` 方法用于处理用户按下 **Enter** 键的行为。当处于 `EXTRUDE_FIXING`（正在确定挤出）阶段时，该方法会解析用户输入的数值，计算挤出方向，并执行挤出操作。

**详细描述**：

1. **调用基类方法**：
   - `Controller_Main::enter(props);` 先执行基类 `Controller_Main` 的 `enter()` 逻辑，确保基础交互流程正确执行。

2. **检查当前挤出状态**：
   - `if(m_extrude_step == ESketchExtrudeStep::EXTRUDE_FIXING)`：
     - 如果当前处于 **EXTRUDE_FIXING**（正在确认挤出），则进入数值解析和执行阶段。

3. **解析用户输入的数值**：
   - `if(this->is_lock())`：检查是否启用了数值输入锁定（用户是否输入了有效的挤出距离）。
   - `if(Util::is_valid_length_expression(m_current_value))`：检查 `m_current_value` 是否是有效的长度表达式。
   - `auto trans = Util::extract_value_and_unit(m_current_value);`：提取数值及单位转换信息，`trans.first` 代表转换后的数值。
   - `float t1 = trans.first;`：存储转换后的数值。

4. **计算挤出方向**：
   - `const nous::vec3 mouse_dir = (m_hover_pos - m_extrude_polygon_begin_position).normalized();`
     - 计算鼠标当前悬停位置相对于挤出起始位置的方向向量。
   - `const int sign = mouse_dir.dot(m_pick_polygon_normal) > 0 ? 1 : -1;`
     - 计算该方向与多边形法向的点积，决定挤出方向（正/负）。

5. **执行挤出**：
   - `if(m_extrude_mode == ESketchExtrudeMode::ADD)`：
     - 如果当前模式是 **ADD**，调用 `create_add_operation_mesh(t1 * sign);` 创建新的几何体。
   - `else if(m_extrude_mode == ESketchExtrudeMode::MOVE)`：
     - 如果当前模式是 **MOVE**，调用 `create_move_operation_mesh(t1 * sign);` 执行挤出移动。

6. **如果输入无效，取消锁定并退出**：
   - `else { _unlock_mouse_move(); return; }`
     - 如果输入的 `m_current_value` 不是有效的数值，则取消鼠标锁定，直接返回。

7. **提交挤出并清理推理系统**：
   - `commit_extrude_mesh();`：提交挤出网格，使修改生效。
   - `View* view = STCore::inst->viewMgr()->layout()->focusedView();`：获取当前焦点视图。
   - `view->inferHelper()->clear_ignore();`：清理推理系统中被忽略的元素。
   - `view->inferHelper()->set_infer_filter_type(InferType::POLYGON);`：重置推理类型为 `POLYGON`，确保下一步仍然关注多边形。
   - `_unlock_mouse_move();`：解锁鼠标移动，允许用户继续操作。
   - `_clear_affected_meshes();`：清除受影响的网格，可能用于清理已处理的几何数据。

8. **清除 `m_current_value`**：
   - `else { m_current_value.clear(); }`：如果不在 `EXTRUDE_FIXING` 状态，则清空 `m_current_value`，防止误操作。

**核心逻辑**：

该方法的主要作用是 **在用户按下 Enter 时，解析数值输入，计算挤出方向，并执行挤出操作，随后提交挤出网格并清理推理系统**。如果输入无效，则取消鼠标锁定，以防止错误操作。

### key_down

**概括描述**：

`key_down()` 方法用于处理键盘按下事件，当 **Shift 键** 被按下时，切换当前的挤出模式（`MOVE` ↔ `ADD`），并刷新视图。

**详细描述**：

1. **检测 Shift 键**：
   - `if(shift)`：仅在 Shift 键按下时执行后续逻辑。

2. **切换网格**：
   - `this->switchMesh();`：调用 `switchMesh()`，可能用于在不同的编辑网格之间切换，确保挤出操作能够正确应用。

3. **切换挤出模式**：
   - `if(m_extrude_mode == ESketchExtrudeMode::MOVE)`：
     - 如果当前模式是 **MOVE**，则切换为 **ADD**。
   - `else if(m_extrude_mode == ESketchExtrudeMode::ADD)`：
     - 如果当前模式是 **ADD**，则切换为 **MOVE**。
   - 这样，每次按下 Shift 键，挤出模式都会在 `MOVE` 和 `ADD` 之间切换。

4. **刷新视图**：
   - `View* pView = STCore::inst->viewMgr()->layout()->focusedView();`：
     - 获取当前焦点视图 (`View`)。
   - `pView->dirtyRT();`：
     - 标记视图需要重新渲染，以更新 UI 显示，例如可能的模式切换指示。

**核心逻辑**：

该方法的主要作用是 **当用户按下 Shift 键时，切换挤出模式（`MOVE` ↔ `ADD`），并刷新视图，以便 UI 反映新的模式**。

### mouse_down

**概括描述**：

`mouse_down()` 方法用于处理 **鼠标左键按下** 事件（`button == 0`）。它根据当前的挤出步骤 (`m_extrude_step`)，决定是进入挤出操作，还是提交挤出。

**详细描述**：

1. **检查鼠标按键**：
   - `if(button != 0) return;`：仅处理 **左键点击** 事件，忽略其他按键。

2. **获取当前视图和推理信息**：
   - `View* view = STCore::inst->viewMgr()->layout()->focusedView();`：
     - 获取当前聚焦的视图对象。
   - `auto& infer_info = view->inferHelper()->get_infer_result();`：
     - 获取推理系统的结果（例如推理出的法线、点位置等）。
   - `auto select_info = view->selector()->get_select_info();`：
     - 获取当前选择的信息，可能用于确定用户选中的元素。

3. **阶段 1：选取多边形（PICK_ELEMENT → EXTRUDE_BEGIN_FIXING）**：
   - `if(m_extrude_step == ESketchExtrudeStep::PICK_ELEMENT)`：
     - 当前处于选取阶段，如果 `select_info.size() == 1`（恰好选择了一个元素），则进入 `EXTRUDE_BEGIN_FIXING` 阶段。

4. **阶段 2：处理选中的几何体（EXTRUDE_BEGIN_FIXING → EXTRUDE_FIXING）**：
   - `if(m_extrude_step == ESketchExtrudeStep::EXTRUDE_BEGIN_FIXING)`：
     - 进入 **RvtBlock** 作用域（用于批量操作场景对象）。
     - `if(!_process_select_info(select_info))`：
       - 如果处理选中元素失败，则回到 `PICK_ELEMENT` 阶段，并退出。
     - **标记需要忽略的对象**：
       - `view->inferHelper()->add_ignore(...)`：将多个 `MeshDoc` 关联的 `renderObject` 标记为推理系统的忽略对象，防止影响后续操作。
       - `dirty()` 方法用于通知 `MeshDoc` 需要更新。

   - **更新挤出状态**：
     - `m_extrude_step = ESketchExtrudeStep::EXTRUDE_FIXING;`
     - `if(m_pick_mesh_doc) m_pick_mesh_doc->dirty();`：
       - 如果 `m_pick_mesh_doc` 存在，标记需要更新，并将 `m_is_extrude_nurbs` 设为 `false`。
     - `if(m_pick_nurbs_doc)`：
       - 如果 `m_pick_nurbs_doc` 存在：
         - 记录挤出的起始位置 `m_extrude_polygon_begin_position`。
         - 记录挤出方向 `m_pick_polygon_normal`。
         - 标记 `m_pick_nurbs_doc` 需要更新 (`dirty()`)。
         - 设定 `m_is_extrude_nurbs = true;`。

5. **阶段 3：提交挤出（EXTRUDE_FIXING → 完成）**：
   - `else if(m_extrude_step == ESketchExtrudeStep::EXTRUDE_FIXING)`：
     - 进入 `RvtBlock` 作用域（用于提交更改）。
     - `commit_extrude_mesh();`：提交挤出操作，使更改生效。
     - `view->inferHelper()->clear_ignore();`：清空推理系统中的忽略列表。
     - `view->inferHelper()->set_infer_filter_type(InferType::POLYGON);`：重置推理类型，继续处理多边形。

**核心逻辑**：

该方法的主要作用是 **处理鼠标左键点击，按照 `PICK_ELEMENT → EXTRUDE_BEGIN_FIXING → EXTRUDE_FIXING` 逻辑执行挤出操作**。如果已经在 `EXTRUDE_FIXING` 阶段，则提交挤出，使更改生效，并清理推理系统的忽略对象。

### mouse_move

**概括描述**：

`mouse_move()` 方法用于 **处理鼠标移动事件**，根据当前挤出步骤 (`m_extrude_step`)，决定是进行选择、推理，还是计算挤出偏移值 (`offset`) 并实时更新几何体。

**详细描述**：

1. **调用基类方法并获取当前视图**：
   - `Controller_Edit::mouse_move(...)`：调用父类方法处理基础鼠标移动逻辑。
   - `View* view = STCore::inst->viewMgr()->layout()->focusedView();`
     - 获取当前聚焦的视图对象，如果 `view` 为空，则直接返回。

2. **获取推理助手 (`InferenceHelper`) 并提取推理信息**：
   - `InferenceHelper* infer_helper = view->inferHelper();`
   - `auto& infer_info = infer_helper->get_infer_result();`

3. **处理不同的挤出步骤 (`m_extrude_step`)**：
   - **`PICK_ELEMENT`（选择元素）**：
     - `_unlock_mouse_move();`
     - `infer_helper->update_inference(view, x, y);`
       - 更新推理系统，尝试获取当前鼠标位置的几何信息。
     - `view->selector()->clear();` 清空当前选中内容。
     - 如果鼠标指向的是多边形 (`POLYGON`) 或曲面 (`SURFACE`)：
       - `view->selector()->add_select_element(infer_info.mesh, element);`
       - 添加该元素到选中集合。
   
   - **`EXTRUDE_BEGIN_FIXING`（准备固定挤出对象）**：
     - `infer_helper->update_inference(view, x, y);`
       - 更新推理信息，确保推理系统能够正确获取鼠标指向的元素。
   
   - **`EXTRUDE_FIXING`（执行挤出）**：
     - 如果 **鼠标未锁定 (`!this->is_lock()`)**：
       - `infer_helper->update_inference(view, x, y);` 获取当前推理信息。
       - 计算鼠标 **拾取射线 (`pick ray`)**：
         - `curr_camera->getDocPickRay(...)` 计算当前鼠标点对应的世界空间射线。
       - 计算射线与法线平面的交点 (`rayIntersect(...)`)：
         - 计算 `offset` 值，即鼠标沿法线方向的偏移距离 `t1`。
   
     - **调整鼠标位置**：
       - `m_hover_pos = m_extrude_polygon_begin_position + offset;`
         - 计算并存储鼠标在挤出方向上的投影位置。
       - `replace_ori_offset = true;`
         - 如果鼠标推理出了一个 **具体点**，则使用 **投影到法线方向的偏移值** 更新 `t1`。
   
     - **根据模式创建挤出几何**：
       - `if(m_extrude_mode == ESketchExtrudeMode::ADD) create_add_operation_mesh(t1);`
       - `else if(m_extrude_mode == ESketchExtrudeMode::MOVE) create_move_operation_mesh(t1);`
       - `else if(m_is_extrude_nurbs) _create_nurbs_operation_mesh(t1);`
         - 根据挤出模式（**新增 or 移动**），或者是否是 **NURBS 挤出**，调用不同的挤出处理逻辑。
   
4. **更新视图**：
   - `view->dirtyRT();`
     - 标记渲染目标 (`RT`) 需要更新，确保新几何体正确显示。

**核心逻辑**：

该方法的主要作用是 **处理鼠标移动时的推理、选取和挤出计算**。
- 在 `PICK_ELEMENT` 阶段，鼠标移动用于高亮可选元素。
- 在 `EXTRUDE_BEGIN_FIXING` 阶段，鼠标移动用于确定最终选择的几何体。
- 在 `EXTRUDE_FIXING` 阶段，鼠标移动用于计算挤出偏移 (`offset`)，并实时更新预览模型。

### mouse_up

**概括描述**：

`mouse_up()` 方法是 `Controller_Extrude_ByNormal` 类的 **鼠标抬起事件** 处理函数，目前为空实现，意味着该类 **不处理鼠标释放事件**。

**详细描述**：

- `mouse_up()` 主要用于 **响应鼠标释放**，通常在拖拽操作或点击操作完成后执行逻辑。
- 由于该函数为空，实现上表明 **该类不依赖鼠标释放事件** 进行任何额外的处理。
- 挤出操作的关键逻辑（如选择、推理、挤出执行）都已经 **在 `mouse_down()` 和 `mouse_move()` 处理完毕**，因此 `mouse_up()` 不需要额外的处理。

**核心逻辑**：

`mouse_up()` 作为 **占位函数**，可能是为了遵循基类 `Controller_Edit` 的接口规范，但该类的 **挤出逻辑完全依赖 `mouse_down()` 和 `mouse_move()`**，所以没有实际代码。

### prepare_render

**概括描述**：

`prepare_render()` 方法用于 **更新和渲染辅助网格**，确保挤出操作的可视化效果。

**详细描述**：

1. **调用 `_update_helper_mesh(view->inferHelper())`**：
   - 该方法可能会更新与 `InferenceHelper` 相关的辅助网格数据，使得当前推理和选择的几何信息能够被正确显示。
   - 这通常用于 **在挤出过程中提供可视化反馈**（例如，高亮显示可选面、预览推理结果等）。

2. **调用 `_render_helper_mesh(view)`**：
   - 该方法可能会将计算好的辅助网格数据提交给渲染管线，以便用户在 `View` 中看到对应的几何结构。
   - 这可能涉及 **绘制预览网格、推理引导线等**，使得挤出操作更加直观。

**核心逻辑**：

该方法的主要作用是 **在 `View` 进行渲染之前，更新并绘制挤出的辅助几何**，确保挤出操作时的视觉反馈清晰直观。

### get_valid_coplane_rings

**概括描述**：

`get_valid_coplane_rings()` 方法用于 **判断并返回与当前选中多边形共面的相邻环（SketchRing）**，确保在挤出过程中正确处理几何拓扑。

**详细描述**：

1. **判断相邻环数量**：
   - 仅当 `line_adj_rings`（与选中环相邻的环）**数量为 2 或 3** 时，才可能存在 **共面的相邻环**。
   - 若不满足此条件，直接返回空集合。

2. **获取当前选中环的法向量**：
   - 选取 `self_rings`（当前选中的环）的 **第一个环的法向量** `self_normal`，用于判断共面关系。

3. **遍历 `line_adj_rings`，筛选共面的环**：
   - 若 `line_adj_rings` 中的环已经存在于 `self_rings`，跳过（避免重复判断）。
   - 计算当前 `adj_ring` 的法向量 `adj_ring_normal`，并 **与选中多边形的法向量 `m_pick_polygon_normal` 计算点积**：
     - 若点积值 `dot_value` **接近 0**（即 `-1e-5 < dot_value < 1e-5`），说明 `adj_ring` **与选中多边形共面**，将其加入 `result` 集合。
     - 否则，说明有不共面的情况，清空 `result` 并直接返回。

**核心逻辑**：

该方法的主要作用是 **从与选中环相邻的环中，筛选出与选中多边形法向量共线的环**，确保在挤出过程中 **正确处理共面拓扑**，防止错误地挤出或合并几何。

### offset_ring_positions

**概括描述**：

`offset_ring_positions()` 方法用于 **计算一个多边形环（SketchRing）沿法向量偏移一定距离后的位置**，以支持拉伸（挤出）操作时的顶点计算。它会在某些情况下添加额外的顶点，以保证拓扑结构的正确性。

**详细描述**：

1. **初始化**：
   - `result`：存储偏移后的位置。
   - `ring_pt_arr`：获取 `ring` 的所有顶点（点的拓扑结构）。
   - `add_order` 和 `first_find` 用于控制点的添加顺序。
   - `check_flags` 记录需要额外检查的顶点索引。

2. **遍历 `ring` 顶点**：
   - **计算偏移位置**：每个 `SketchPointPtr`（`curr_pt`）按 `m_pick_polygon_normal * offset` 计算偏移后的 `offset_pos`。
   - **处理 `prev_pt` 和 `next_pt`（特殊点）**：
     - 判断 `curr_pt` 是否为 `prev_pt` 或 `next_pt`。
     - 若 `curr_pt` 为 `prev_pt`，则确定相邻点的方向（前一个或后一个）。
     - 计算 `curr_pt` 到相邻点的方向向量 `line_dir`，并与法向量 `m_pick_polygon_normal` 点积 `dot_v`：
       - 若点积接近 `0`（不共线），则添加 `curr_pt` 和 `offset_pos`。
       - 否则只添加 `offset_pos`，并记录 `check_flags` 以便后续检查冗余点。

3. **检查 `check_flags` 记录的顶点是否冗余**：
   - 遍历 `result`，寻找与 `m_pick_polygon_normal` 平行的线段，标记可能的冗余点。
   - 计算 `i` 到 `j` 之间的点，并将非必要点记录到 `delete_id_set`。
   - 最后，从 `result` 中删除冗余点。

**核心逻辑**：

该方法的主要作用是 **基于法向量偏移原有多边形环的位置，同时确保拓扑结构合理，避免不必要的额外顶点或错误的拓扑连接**。它通过 **点积计算共线性** 以及 **冗余点检测** 来优化最终的点集，确保挤出后的多边形保持正确的结构。

### get_offseted_polygon_positions

**概括描述**：

`get_offseted_polygon_positions()` 方法用于 **计算一个多边形（`SketchPolygonPtr`）沿法向量偏移一定距离后的所有环（外环和内环）的新位置**，主要用于拉伸（挤出）操作。

**详细描述**：

1. **计算外环（`ring`）的偏移位置**：
   - 调用 `offset_ring_positions()` 计算 `polygon->ring` 沿 `offset` 方向的偏移位置，并存入 `exring_pos_arr`。
   - 将 `exring_pos_arr` 移入 `result`，作为偏移后的外环。

2. **计算内环（`inner_rings`）的偏移位置**：
   - 遍历 `polygon->inner_rings`，对每个 `inner_ring` 调用 `offset_ring_positions()` 计算其偏移后的位置。
   - 将结果依次添加到 `result`，确保所有内环的偏移数据被存储。

3. **返回 `result`**：
   - `result` 是一个二维 `std::vector<std::vector<nous::vec3>>`，第一项是外环的偏移位置，后续项是所有内环的偏移位置。

**核心逻辑**：

该方法 **调用 `offset_ring_positions()` 处理所有的环（包括外环和内环）**，确保整个多边形在挤出时保持拓扑结构不变。最终返回的是 **偏移后的多边形环坐标集合**，用于后续几何计算或渲染更新。

### need_flip_picked_normal

**概括描述**：

`need_flip_picked_normal()` 方法 **判断所选多边形的法向（`m_pick_polygon_normal`）在挤出方向上是否会受到邻近几何体的限制**，进而决定 **是否需要翻转法向** 以及 **哪一侧（正方向/负方向）可以进行移动**。

**详细描述**：

1. **初始化平面法向和标志变量**：
   - 获取当前多边形的 **法向量 `plane_normal`**，该法向定义了多边形所在的平面。
   - 使用 **两个标志变量**：
     - `is_positive_plane_normal_valid = 1`（正方向有效）
     - `is_negative_plane_normal_valid = 2`（负方向有效）

2. **遍历 `m_selected_polygon_topo`（存储被选中多边形的拓扑信息）**：
   - 对每个环的每条边：
     - 计算 **起点 `prev_point` 和终点 `next_point` 的坐标**。
     - 计算 **沿法向量 `plane_normal` 正方向和负方向偏移 0.011 的新坐标**（`positive_offset_prev_pos` / `negative_offset_prev_pos`）。
     - 遍历 `prev_point` 和 `next_point` 的所有邻接点 `nei_pt`：
       - 计算与 `prev_point` 的连线方向 `link_line_dir`，如果与当前边的方向 `line_dir` 平行，则跳过。
       - 进行 **3D 直线求交运算**：
         - `nous::algo::line_intersect_3d()` 计算 **偏移后线段（正方向或负方向）是否与 `prev_point` - `nei_pt` 相交**。
         - 如果相交并且距离小于 `1e-5`，则说明该方向受到约束，设置 `is_positive_plane_normal_valid` 或 `is_negative_plane_normal_valid` 为 `false`。

3. **返回最终移动方向**：
   - `is_positive_plane_normal_valid + is_negative_plane_normal_valid` 组合成最终的 **移动方向标志**：
     - **3（Both）** → 可以沿正负方向移动。
     - **1（Positive）** → 只能沿正方向移动。
     - **2（Negative）** → 只能沿负方向移动。
     - **0（None）** → 不能移动。

**核心逻辑**：

该方法 **通过偏移多边形法向的边界，并检测是否与其他几何体相交**，来 **判断是否允许沿正方向或负方向挤出**。最终返回 `ESketchExtrudeMoveValidDir` 枚举值，以指导后续挤出操作。

### processPickPolygon

**概括描述**：

`processPickPolygon()` 负责处理用户选择的多边形（`pick_polygon`），并 **计算挤出所需的法向信息**，初始化 **选中的多边形拓扑结构**，并 **准备相应的几何体进行挤出计算**。

**详细描述**：

1. **转换法向到世界坐标系**：
   - 获取 `m_pick_mesh_doc`（选中网格文档）的 **世界变换矩阵 `mat`**。
   - 计算选中多边形 **`pick_polygon`** 的 **法向 `m_pick_polygon_normal`**：
     - 先从 `pick_polygon->ring->normal` 获取 **模型空间的法向**。
     - 使用 `NousConvert::product_v3()` 将其转换到 **世界空间**。

2. **计算多边形中心点**：
   - 调用 `picked_geo->get_mesh()->prim_barycenter()` 获取 `ring->ring_prim->idx()` 的 **中心位置**，存储在 `m_extrude_polygon_begin_position`。

3. **处理包含多个内环的情况**：
   - 通过 `GeoDataUtils::get().get_ring_topo()` 获取选中多边形 **外环 `out_ring`**。
   - 如果 `pick_polygon` 存在 **内环**：
     - 遍历 `pick_polygon->inner_rings`，获取所有内环拓扑结构 `inner_rings`。
     - 使用 `geodata_topo::ring_difference_other_rings()` **合并相邻的离散内环**，得到 `valid_polygons`。
     - 若 `valid_polygons` 仅包含一个多边形，则将其存入 `pick_polygen_rings_topo`。
   - 否则，直接存入 **外环 `out_ring`**。

4. **存储最终选中的多边形拓扑结构**：
   - `m_selected_polygon_topo = pick_polygen_rings_topo;`

5. **准备推测（inferring）网格**：
   - 调用 `prepare_add_mode_inferring_mesh()` **创建用于新增模式的推测网格**。
   - 调用 `prepare_move_mode_inferring_mesh(picked_geo, pick_polygon)` **创建用于移动模式的推测网格**。

6. **隐藏不需要显示的对象**：
   - 如果当前模式是 `MOVE`：
     - 隐藏 `m_add_inferring_mesh_doc` 和 `m_copyed_origin_mesh_doc`。
   - 如果当前模式是 `ADD`：
     - 隐藏 `m_move_inferring_mesh_doc` 和 `m_pick_mesh_doc`。
   - 隐藏 `m_splited_old_mesh_doc`。

7. **通知视图更新隐藏对象**：
   - 通过 `view->setHideObjects(hide_docs)` 隐藏指定的对象。

8. **标记推测网格为“脏”**（即需要重新渲染）：
   - `m_add_inferring_mesh_doc->dirty();`
   - `m_move_inferring_mesh_doc->dirty();`
   - `m_pick_mesh_doc->dirty();`

**核心逻辑**：

- **转换法向信息** → 确保法向在世界坐标系中正确计算。
- **处理离散内环** → 使多边形拓扑结构完整且连贯，以便挤出。
- **准备推测网格** → 计算 `ADD` 和 `MOVE` 模式下的几何体。
- **隐藏不需要的几何体** → 避免界面干扰，提高交互体验。
- **更新状态** → 让 `m_pick_mesh_doc` 和相关推测网格重新渲染，保证视觉反馈。

### create_move_operation_mesh

**概括描述**：

`create_move_operation_mesh(double offset)` 方法用于 **基于当前挤出偏移量 `offset` 移动推测网格**，并 **更新所有受影响的点的位置**。

**详细描述**：

1. **限制 `offset` 范围**：
   - 若 `offset` **超过正向最大限制 `m_positive_offset_limit`**，则将 `offset` 设为 `m_positive_offset_limit`。
   - 若 `offset` **低于负向最大限制 `m_negative_offset_limit`**，则将 `offset` 设为 `-m_negative_offset_limit`。

2. **更新移动模式的推测网格**：
   - 如果 `m_move_inferring_mesh_doc` 存在：
     - **计算当前偏移增量 `delta_offset`** = 当前 `offset` - 上一次 `offset`（`m_move_last_offset`）。
     - **更新 `m_move_last_offset`** 为 `offset`。
     - **计算实际位移 `fitted_offset`** = `delta_offset` * `m_pick_polygon_normal`（**沿法向移动**）。

3. **更新所有受影响的点的位置**：
   - 遍历 `m_new_move_polygon_topo`（即所有需要移动的点）：
     - 获取 `middle_pos`（当前点的位置）。
     - 计算新位置 `new_pos` = `middle_pos` + `fitted_offset`。
     - 调用 `set_point_position(pt, new_pos)` **更新点的位置**。

4. **标记 `m_move_inferring_mesh_doc` 为脏（需要重新渲染）**：
   - `m_move_inferring_mesh_doc->geodata()->mark_all_sketch_polygon_dirty();` **标记所有多边形为“脏”**（需要更新）。
   - `m_move_inferring_mesh_doc->dirty();` **标记整个推测网格为“脏”**。

**核心逻辑**：

- **约束 `offset` 的合法范围**，防止挤出超出允许的偏移值。
- **计算增量位移 `delta_offset`**，确保每次都基于上次的偏移进行调整。
- **遍历受影响的点**，计算新位置，并进行 **法向方向上的位移**。
- **标记网格更新**，确保 `View` 重新渲染，反映最新的挤出效果。

### create_add_operation_mesh

**概括描述**：

`create_add_operation_mesh(double offset)` 方法用于 **基于当前挤出偏移量 `offset` 计算新增多边形的推测网格**，并 **更新所有受影响点的位置**。

**详细描述**：

1. **检查 `m_add_inferring_mesh_doc` 是否存在**：
   - 若该网格文档存在，则继续执行，否则直接返回。

2. **计算当前偏移增量 `delta_offset`**：
   - `delta_offset = offset - m_add_last_offset`（当前偏移量 `offset` **减去** 上一次偏移量 `m_add_last_offset`）。
   - 更新 `m_add_last_offset = offset`，确保 **增量计算是基于上次的偏移**，避免累积误差。

3. **计算实际位移 `fitted_offset`**：
   - `fitted_offset = delta_offset * m_pick_polygon_normal`，即 **沿法向方向 `m_pick_polygon_normal` 移动**。

4. **遍历所有新增多边形的顶点 `m_new_add_polygon_topo`**：
   - 获取 `middle_pos`（当前点的位置）。
   - 计算新位置 `new_pos = middle_pos + fitted_offset`。
   - 调用 `set_point_position(pt, new_pos)` **更新点的位置**。

5. **标记 `m_add_inferring_mesh_doc` 为脏（需要重新渲染）**：
   - `m_add_inferring_mesh_doc->geodata()->mark_all_sketch_polygon_dirty();` **标记所有多边形为“脏”**（需要更新）。
   - `m_add_inferring_mesh_doc->dirty();` **标记整个推测网格为“脏”**。

**核心逻辑**：

- **基于 `offset` 计算位移增量 `delta_offset`，确保偏移变化的连贯性**。
- **遍历所有受影响点，将其沿法线方向移动**，确保新增多边形正确跟随挤出操作。
- **标记网格更新**，确保 `View` 重新渲染，反映最新的挤出效果。

### commit_extrude_mesh

**概括描述**：

`commit_extrude_mesh()` 方法用于 **提交挤出操作的最终结果**，将 **推测的几何体合并到原始网格**，并清理临时对象。

**详细描述**：

1. **获取当前 `View` 和 `Scene`**：
   - `view = STCore::inst->viewMgr()->layout()->focusedView();`
   - `scene = view->doc()->scene();`
   - 清除 `View` 中的隐藏对象 `view->clearHideObjects();`。

2. **处理 `m_pick_mesh_doc`（用于普通网格挤出）**：
   - **如果当前模式为 `ADD`（新增模式）**：
     - 合并 `m_splited_old_mesh_doc`（被分割的旧网格）。
     - 合并 `m_add_inferring_mesh_doc`（新增的推测网格），然后删除 `m_add_inferring_mesh_doc`。
     - 删除 `m_move_inferring_mesh_doc`（移动推测网格）。

   - **如果当前模式为 `MOVE`（移动模式）**：
     - **修复 `m_move_inferring_mesh_doc`**（`fix_inferring_mesh_doc()`）。
     - **尝试合并 `m_move_inferring_mesh_doc`**：
       - 若合并失败，调用 `deactive()` 结束操作，并输出错误信息。
     - 删除 `m_splited_old_mesh_doc` 和 `m_add_inferring_mesh_doc`。

   - **删除 `m_copyed_origin_mesh_doc`**（复制的原始网格）。

3. **处理 `m_pick_nurbs_doc`（用于 `NURBS` 挤出）**：
   - 获取 `NurbsDataPtr nurbs_data`。
   - 遍历 `m_tmp_surfaces_guid`，删除 `AlgebraSurface` 或 `ClosedSurface` 类型的临时 `NURBS` 曲面。
   - 若类型为 `AlgebraSurface`，设置 **渲染级别** 为 `Solid`。
   - 创建 `NurbsComplexSurface` 并 **添加到 `nurbs_data`**。
   - 标记 `m_pick_nurbs_doc` 为脏（`dirty()`），触发更新。

4. **重置挤出步骤和缓存**：
   - 设置 `m_extrude_step = ESketchExtrudeStep::PICK_ELEMENT;`（返回到初始状态）。
   - 清除所有缓存：
     - `clear_limits();`
     - `m_new_move_polygon_topo.clear();`
     - `m_new_add_polygon_topo.clear();`
     - `m_tmp_surfaces_guid.clear();`

**核心逻辑**：

- **合并推测的 `ADD/MOVE` 网格到原始网格**，确保挤出操作生效。
- **删除所有不再需要的 `MeshDoc`**，避免内存泄漏。
- **对于 `NURBS` 挤出，创建 `NurbsComplexSurface` 并更新 `NurbsData`**。
- **清理所有缓存数据，重置 `m_extrude_step`，准备下一次挤出**。

### switchMesh

**概括描述**：

`switchMesh()` 方法用于 **在挤出操作的“移动模式（MOVE）”和“新增模式（ADD）”之间切换**，并确保相应的网格文档（`MeshDoc`）可见或隐藏。

**详细描述**：

1. **仅在 `EXTRUDE_FIXING` 状态下允许切换**：
   - 如果当前 `m_extrude_step` **不是 `EXTRUDE_FIXING`**，则直接返回。

2. **获取 `View` 并清理隐藏对象**：
   - `view = STCore::inst->viewMgr()->layout()->focusedView();`
   - `view->clearHideObjects();` 清除当前 `View` 内隐藏的对象。
   - 创建 `std::unordered_set<ObjectDoc*> hide_docs;` 存放 **即将被隐藏的 `MeshDoc`**。

3. **如果当前模式为 `MOVE`（移动模式）**：
   - **隐藏**：
     - `m_move_inferring_mesh_doc`（移动推测网格）。
     - `m_splited_old_mesh_doc`（被分割的旧网格）。
     - `m_pick_mesh_doc`（原始网格）。
   - **切换到 `ADD` 模式**：
     - 调用 `create_add_operation_mesh(m_move_last_offset);` **创建新增推测网格**。

4. **如果当前模式为 `ADD`（新增模式）**：
   - **隐藏**：
     - `m_add_inferring_mesh_doc`（新增推测网格）。
     - `m_splited_old_mesh_doc`（被分割的旧网格）。
     - `m_copyed_origin_mesh_doc`（复制的原始网格）。
   - **切换到 `MOVE` 模式**：
     - 调用 `create_move_operation_mesh(m_add_last_offset);` **创建移动推测网格**。

5. **更新 `View` 的隐藏对象**：
   - `view->setHideObjects(hide_docs);` **应用新的隐藏对象**。

**核心逻辑**：

- **确保 `EXTRUDE_FIXING` 状态下才能切换模式**。
- **在 `MOVE` 和 `ADD` 之间切换**，隐藏当前模式的网格，显示目标模式的网格。
- **调用 `create_add_operation_mesh()` 或 `create_move_operation_mesh()`，保持推测网格的正确性**。

### prepare_add_mode_inferring_mesh

**概括描述**：

`prepare_add_mode_inferring_mesh()` 方法用于 **为“新增模式（ADD）”的挤出操作创建推测网格**，包括 **初始化网格对象、计算偏移位置，并生成新的侧面多边形**。

**详细描述**：

1. **获取 `View` 和 `SceneDoc`**：
   - `view = STCore::inst->viewMgr()->layout()->focusedView();`
   - `scene = view->doc()->scene();`

2. **删除已有的 `m_add_inferring_mesh_doc` 和 `m_copyed_origin_mesh_doc`**：
   - `view->delete_obj_and_try_delete_relation(m_add_inferring_mesh_doc);`
   - `view->delete_obj_and_try_delete_relation(m_copyed_origin_mesh_doc);`
   - 置空 `m_add_inferring_mesh_doc` 和 `m_copyed_origin_mesh_doc`。

3. **创建新的 `m_add_inferring_mesh_doc`（推测新增网格）**：
   - `m_add_inferring_mesh_doc = (MeshDoc*)view->create_obj_in_working_group(Define::OBJ_D5_MESH);`

4. **创建 `m_copyed_origin_mesh_doc`（用于存储原始网格的副本）**：
   - `m_copyed_origin_mesh_doc = (MeshDoc*)view->create_obj_in_working_group(Define::OBJ_D5_MESH);`
   - `m_copyed_origin_mesh_doc->copy_from(m_pick_mesh_doc);` **复制原始网格数据**。

5. **设置默认偏移量 `move_delta = 0.1`**：
   - `m_add_last_offset = move_delta;` **记录偏移量**。

6. **计算新多边形的位置**：
   - 遍历 `m_selected_polygon_topo`（当前选中的多边形拓扑）。
   - **计算每个点的新位置**：
     - `curr_pt_pos + m_add_last_offset * m_pick_polygon_normal`
     - `next_pt_pos + m_add_last_offset * m_pick_polygon_normal`
   - 生成新的侧面多边形 `{ curr_pt_pos, next_pt_pos, new_next_pt_pos, new_curr_pt_pos }`，并添加到 `m_add_inferring_mesh_doc`。

7. **存储新创建的多边形数据**：
   - `m_new_add_polygon_topo_arr = m_add_inferring_mesh_doc->geodata()->add_polygon(new_polygon_pos);`
   - **更新 `m_new_add_polygon_topo`（存储所有新增点）**。

8. **标记 `m_add_inferring_mesh_doc` 为脏数据（需要重新渲染）**：
   - `m_add_inferring_mesh_doc->dirty();`
   - `m_add_inferring_mesh_doc->geodata()->dirty();`

**核心逻辑**：

- **删除旧的推测网格，创建新的推测网格和原始网格副本**。
- **计算偏移后的位置，构造侧面多边形，并存储新拓扑数据**。
- **最终更新 `m_add_inferring_mesh_doc`，以便在视图中正确渲染**。

### prepare_move_mode_inferring_mesh

**概括描述**：

`prepare_move_mode_inferring_mesh()` 方法用于 **为“移动模式（MOVE）”的挤出操作创建推测网格**，判断 **挤出的合法方向**，**构造新顶面和侧面**，并 **计算可移动范围**。

**详细描述**：

1. **判断是否需要反转法线方向**：
   - 调用 `need_flip_picked_normal(picked_geo, pick_polygon)` **计算挤出方向的合法性**。
   - 若 **无法前后移动（`None`）**，则直接提交当前挤出操作并返回。

2. **设置偏移值 `move_delta`**：
   - 若 **只能负方向移动**（`Negative`），则 `move_delta = -move_delta`。
   - 记录 `m_move_last_offset`。

3. **清理旧的推测网格**：
   - **删除旧的 `m_move_inferring_mesh_doc`（移动推测网格）**。
   - **删除旧的 `m_splited_old_mesh_doc`（用于恢复的旧网格）**。

4. **创建新的推测网格**：
   - `m_move_inferring_mesh_doc` **存储挤出后的形态**。
   - `m_splited_old_mesh_doc` **用于存储操作前的形态**。

5. **查找选中面相邻的共面多边形**：
   - 遍历 `m_selected_polygon_topo`（选中多边形的拓扑）。
   - 对于每条边：
     - 判断 **是否有与之共面的环**，记录 `line_corr_coplane_ring_map`。

6. **处理共面多边形**：
   - 若 **边存在共面多边形**：
     - 计算 **可移动的最大距离**（`m_negative_offset_limit` & `m_positive_offset_limit`）。
     - 生成 **偏移后的多边形** 并存入 `m_move_inferring_mesh_doc`。

7. **处理不共面的边**：
   - 若 **边不存在共面多边形**：
     - 计算 **新建侧面**，并加入 `m_move_inferring_mesh_doc`。

8. **删除旧的底面，更新顶面**：
   - **删除 `pick_polygon`（被选中的原始多边形）**。
   - **添加新的偏移顶面** 到 `m_move_inferring_mesh_doc`。

9. **调整 `m_negative_offset_limit` 和 `m_positive_offset_limit`**：
   - 若只能 **正方向挤出**，`m_negative_offset_limit = 0.0`。
   - 若只能 **负方向挤出**，`m_positive_offset_limit = 0.0`。

**核心逻辑**：

- **先判断挤出方向是否合法**，如果不可移动，则直接结束操作。
- **查找共面多边形，处理其偏移，并计算挤出限制**。
- **删除旧顶面，创建偏移后的新顶面，并更新推测网格**。

### clear_all_cache_mesh_doc

**概括描述**：

`clear_all_cache_mesh_doc()` 方法用于 **清理所有缓存的网格文档**，恢复原始数据，释放临时对象，并删除与挤出操作相关的缓存数据。

**详细描述**：

1. **清理隐藏对象**：
   - 调用 `view->clearHideObjects()` **取消所有隐藏对象**。

2. **清理推测网格（Inferring Mesh）**：
   - 调用 `clear_inferring_mesh_doc()` **清理推测网格**（`m_add_inferring_mesh_doc` 和 `m_move_inferring_mesh_doc`）。

3. **恢复旧网格**：
   - 若 `m_splited_old_mesh_doc` 存在：
     - **合并 `m_splited_old_mesh_doc` 到 `m_pick_mesh_doc`**，恢复修改前的数据。
     - **删除 `m_splited_old_mesh_doc`**。

4. **删除复制的原始网格**：
   - 若 `m_copyed_origin_mesh_doc` 存在：
     - **删除 `m_copyed_origin_mesh_doc`**，释放内存。

5. **清理 NURBS 相关数据**：
   - 若 `m_pick_nurbs_doc` 存在：
     - **遍历 `m_tmp_surfaces_guid`，删除临时曲面数据**。
     - **清空 `m_tmp_surfaces_guid`**。
     - **标记 `m_pick_nurbs_doc` 需要更新**（`dirty()`）。
     - **置空 `m_pick_nurbs_doc`**。

**核心逻辑**：

- **清理所有与挤出相关的缓存数据**，包括 **推测网格、复制的原始网格、分割的旧网格，以及 NURBS 临时数据**，确保内存释放和数据恢复。

### clear_inferring_mesh_doc

**概括描述**：

`clear_inferring_mesh_doc()` 方法 **清除推测网格文档（Inferring Mesh）**，确保在挤出操作过程中释放不再需要的临时网格数据。

**详细描述**：

1. **获取当前视图 `View`**：
   - 通过 `STCore::inst->viewMgr()->layout()->focusedView()` 获取当前活跃视图。

2. **检查是否处于 `EXTRUDE_FIXING` 状态**：
   - **仅当 `m_extrude_step == ESketchExtrudeStep::EXTRUDE_FIXING` 时** 才执行清理操作，确保只在适当阶段清除推测网格。

3. **清除 `m_move_inferring_mesh_doc`（用于移动挤出模式的网格）**：
   - 若 `m_move_inferring_mesh_doc` 存在：
     - 调用 `view->delete_obj_and_try_delete_relation(m_move_inferring_mesh_doc)` **删除该网格对象**。
     - 将 `m_move_inferring_mesh_doc` 设为 `nullptr`，避免悬空指针。

4. **清除 `m_add_inferring_mesh_doc`（用于新增挤出模式的网格）**：
   - 若 `m_add_inferring_mesh_doc` 存在：
     - 调用 `view->delete_obj_and_try_delete_relation(m_add_inferring_mesh_doc)` **删除该网格对象**。
     - 将 `m_add_inferring_mesh_doc` 设为 `nullptr`，释放内存。

**核心逻辑**：

**在 `EXTRUDE_FIXING` 步骤下**，**删除 `m_move_inferring_mesh_doc` 和 `m_add_inferring_mesh_doc`**，确保挤出操作过程中不存留无用的推测网格数据。

### clear_limits

**概括描述**：

`clear_limits()` 方法 **重置挤出操作的偏移限制和方向**，确保新的挤出操作不会受到旧数据的影响。

**详细描述**：

1. **重置 `m_negative_offset_limit`（负方向偏移限制）**：
   - 设为 `std::numeric_limits<double>::max()`，表示无限制。

2. **重置 `m_positive_offset_limit`（正方向偏移限制）**：
   - 设为 `std::numeric_limits<double>::max()`，表示无限制。

3. **重置 `m_valid_move_dir`（有效移动方向）**：
   - 设为 `ESketchExtrudeMoveValidDir::None`，表示当前没有可用的挤出方向。

4. **重置 `m_move_last_offset`（上次移动偏移量）**：
   - 设为 `0.0`，表示无初始偏移。

5. **重置 `m_add_last_offset`（上次新增偏移量）**：
   - 设为 `0.0`，确保新增挤出时偏移量从 `0` 开始计算。

**核心逻辑**：

**确保挤出操作的参数清零**，避免上一次的挤出影响新的操作，使 `Controller_Extrude_ByNormal` 进入一个干净的初始状态。

### fix_inferring_mesh_doc

**概括描述**：

`fix_inferring_mesh_doc()` 方法 **修复挤出过程中推导出的网格（inferring mesh）中的拓扑问题**，确保其符合几何约束并且不会在挤出后出现错误的形状。

**详细描述**：

1. **检查 `m_move_inferring_mesh_doc` 是否存在**：
   - 如果存在，则获取其 `GeoData` 及所有 `SketchPolygonPtr`（推导出的多边形）。

2. **遍历 `all_sketch_polygons`（所有多边形）**：
   - **跳过顶部多边形**，即当前挤出的顶面。
   - 对每个多边形，**计算是否存在自交或错误拓扑**。

3. **尝试分割存在拓扑问题的多边形**：
   - 使用 `geodata_topo::ring_difference_other_rings()` 计算该多边形的**外环**与**内环**的差异，获得分割后的多边形集合。
   - 如果 `splited_polygons` 为空，则手动获取原始拓扑数据。

4. **检查分割后的每个新多边形**：
   - 遍历 `splited_polygons` 的**每个环**：
     - **如果外环被分割**（由共用边导致），则将新的部分保存。
     - **如果外环未被分割**，直接保存该多边形。
     - **如果内环被分割**，则进行进一步处理。

5. **将所有修复后的多边形重新添加到 `GeoData`**：
   - 先删除原来的 `polygon`，然后添加新的拓扑。
   - 如果新的多边形仍然存在拓扑问题，尝试 `sketch::topo::fix_one_point_repeated_polygon()` 进行修复。
   - 确保所有新生成的多边形通过 `GeoDataTopoOperations::get().add_polygon_without_split_line()` 添加到 `GeoData`。

**核心逻辑**：

- **修复拓扑错误**： 解决因挤出过程导致的几何交叉、重复点、非法拓扑问题。
- **处理分割逻辑**： 确保被挤出的多边形正确保留或分解，不会产生错误形状。
- **确保拓扑有效性**： 通过 `geos_util::is_polygon_valid()` 进行检查，并在必要时使用 `sketch::topo::fix_one_point_repeated_polygon()` 进行修复。

### _process_select_info

**概括描述**：

`_process_select_info()` 方法 **处理用户选择的信息，确定当前选择的是网格（Mesh）还是 NURBS（Non-Uniform Rational B-Spline）对象，并进行相应的数据提取**。

**详细描述**：

1. **初始化相关变量**：
   - `valid_element_number` 记录有效的选中元素数。
   - `m_selected_algebra_surface`、`m_selected_closed_surface`、`m_selected_complex_surface` 置空，以确保新的选择不会受之前状态的影响。

2. **遍历 `select_info_map`（用户选择的信息）**：
   - **如果是网格对象 (`OBJ_D5_MESH`)**：
     - **如果已选择多个多边形或已存在有效选中对象**，则增加 `valid_element_number` 并跳出循环。
     - **遍历所有选中的 `SketchElementPtr`**：
       - 如果是 `SketchPolygonPtr`，则：
         1. 记录 `m_pick_mesh_doc`（选中的 `MeshDoc`）。
         2. 置空 `m_pick_nurbs_doc`（因为是网格）。
         3. 调用 `processPickPolygon()` 处理选中的 `SketchRingPtr`（多边形的外环）。
         4. 递增 `valid_element_number`。

   - **如果是 NURBS 对象 (`OBJ_D5_NURBS`)**：
     - 获取 `NurbsDoc*` 和其 `NurbsDataPtr` 以提取选中的曲面数据。
     - 遍历所有 `SketchElementPtr`：
       - 如果是 `AlgebraSurface`，设置 `m_selected_algebra_surface` 并标记 `m_pick_nurbs_doc`。
       - 如果是 `ClosedSurface`，设置 `m_selected_closed_surface` 并标记 `m_pick_nurbs_doc`。
       - 如果是 `ComplexSurface`，设置 `m_selected_complex_surface` 并标记 `m_pick_nurbs_doc`。
       - 每次匹配到一个合法对象，`valid_element_number` 递增。

3. **有效性检查**：
   - **如果 `valid_element_number` 不是 1**（意味着用户选中了多个对象或无效对象），则：
     - 置空 `m_selected_algebra_surface` 和 `m_selected_closed_surface`。
     - 返回 `false`，表示选择无效。
   - **否则，返回 `true`**，表示成功处理了选中的对象。

**核心逻辑**：

- **检查用户选择的是网格（Mesh）还是 NURBS**，并将数据存储到 `m_pick_mesh_doc` 或 `m_pick_nurbs_doc`。
- **确保只有一个有效选中对象**，避免多选导致的错误操作。
- **调用 `processPickPolygon()` 处理选中的网格多边形，并确保 `GeoData` 正确加载**。

### _create_nurbs_operation_mesh

**概括描述**：

`_create_nurbs_operation_mesh()` **根据当前选中的 NURBS 曲面类型（代数曲面、封闭曲面、复杂曲面）调用相应的网格生成方法**。

**详细描述**：

1. **判断当前选中的 NURBS 类型**：
   - 如果 `m_selected_algebra_surface` 不为空，则调用 `_generate_algebra_surface_operation_mesh(value)` **生成代数曲面操作网格**。
   - 如果 `m_selected_closed_surface` 不为空，则调用 `_generate_closed_surface_operation_mesh(value)` **生成封闭曲面操作网格**。
   - 如果 `m_selected_complex_surface` 不为空，则调用 `_generate_complex_surface_operation_mesh(value)` **生成复杂曲面操作网格**。

2. **传递参数 `value`**：
   - `value` 代表 **挤出操作的偏移量**，影响曲面变形的程度。

**核心逻辑**：

- **根据选中的 NURBS 类型调用不同的网格生成方法**。
- **确保 `value` 正确传递到对应的网格操作方法**，以便挤出正确的形状。
- **仅针对 NURBS（而非网格 Mesh）进行处理**。

### _generate_algebra_surface_operation_mesh

**概括描述**：

`_generate_algebra_surface_operation_mesh()` **基于法线方向对代数曲面（Algebra Surface）进行挤出操作**，生成新的曲面，同时保持原始形状的距离关系。

**详细描述**：

1. **清理临时曲面数据**：
   - 获取 `m_pick_nurbs_doc` 关联的 `nurbs_data`。
   - **删除** 之前存储在 `m_tmp_surfaces_guid` 中的曲面，避免重复数据。

2. **检查 `value` 是否接近零**：
   - 若 `value` **小于 `1e-5`，表示偏移量过小**，无需进行挤出，直接返回。

3. **进行曲面挤出**：
   - 调用 `nurbs::extrude_surface_by_normal_keep_distance()`，基于 `m_selected_algebra_surface` 及 `value` 生成新的挤出曲面。
   - `value` **控制挤出方向和距离**。

4. **更新 NURBS 数据**：
   - **遍历新生成的曲面**：
     - 若曲面类型为 `AlgebraSurface`，设置渲染模式为 `WireFrame`（线框模式）。
     - 添加新曲面到 `nurbs_data`。
     - 记录曲面 `ID` 到 `m_tmp_surfaces_guid`，方便后续管理。

5. **标记 `m_pick_nurbs_doc` 需要更新**。

**核心逻辑**：

- **先删除旧的挤出曲面，防止重复计算**。
- **使用 `extrude_surface_by_normal_keep_distance()` 进行法线方向上的挤出**，确保几何形状的稳定性。
- **更新 `nurbs_data` 以存储新的 NURBS 结构**，并标记文档需要刷新。

### _generate_closed_surface_operation_mesh

**概括描述**：

`_generate_closed_surface_operation_mesh()` **基于法线方向对封闭曲面（Closed Surface）进行挤出操作**，生成新的封闭曲面，确保几何拓扑关系保持稳定。

**详细描述**：

1. **清理临时曲面数据**：
   - 获取 `m_pick_nurbs_doc` 关联的 `nurbs_data`。
   - **删除** 之前存储在 `m_tmp_surfaces_guid` 中的曲面，以避免重复数据。

2. **检查 `value` 是否足够大**：
   - 若 `value` **小于 `1e-5`**，表示偏移量太小，直接返回。

3. **进行曲面挤出**：
   - 调用 `nurbs::extrude_surface_by_normal()` **基于 `m_selected_closed_surface`、挤出距离 `value` 以及 `m_pick_polygon_normal` 生成新的曲面**。

4. **更新 NURBS 数据**：
   - **遍历新生成的曲面**：
     - 若曲面类型为 `AlgebraSurface`，设置渲染模式为 `WireFrame`（线框模式）。
     - 将新曲面 **添加到 `nurbs_data`**。
     - 记录曲面 `ID` 到 `m_tmp_surfaces_guid`，方便后续管理。

5. **标记 `m_pick_nurbs_doc` 需要更新**。

**核心逻辑**：

- **清理旧数据，防止多次执行导致的数据污染**。
- **通过 `extrude_surface_by_normal()` 在法线方向上进行挤出**，确保封闭曲面仍然符合拓扑要求。
- **更新 `nurbs_data` 以存储新的 NURBS 结构，并标记需要刷新**。

### _generate_complex_surface_operation_mesh

**概括描述**：

`_generate_complex_surface_operation_mesh()` **基于法线方向对复杂曲面（Complex Surface）进行挤出操作**，生成新的 NURBS 曲面，并确保其拓扑关系保持稳定。

**详细描述**：

1. **清理临时曲面数据**：
   - 获取 `m_pick_nurbs_doc` 关联的 `nurbs_data`。
   - **删除** 之前存储在 `m_tmp_surfaces_guid` 中的曲面，以避免重复数据。

2. **检查 `value` 是否足够大**：
   - 若 `value` **小于 `1e-5`**，表示偏移量太小，直接返回。

3. **进行曲面挤出**：
   - 调用 `nurbs::extrude_surface_by_normal_keep_distance()` **基于 `m_selected_complex_surface` 和 `value` 生成新的曲面**。

4. **更新 NURBS 数据**：
   - **遍历新生成的曲面**：
     - 若曲面类型为 `AlgebraSurface`，设置渲染模式为 `WireFrame`（线框模式）。
     - 将新曲面 **添加到 `nurbs_data`**。
     - **标记曲面为 `dirty`**，确保渲染更新。
     - 记录曲面 `ID` 到 `m_tmp_surfaces_guid`，方便后续管理。

5. **清理临时变量**：
   - 调用 `new_surfaces.clear()` 释放临时存储的曲面数据。

6. **标记 `m_pick_nurbs_doc` 需要更新**。

**核心逻辑**：

- **清理旧数据，防止多次执行导致的数据污染**。
- **通过 `extrude_surface_by_normal_keep_distance()` 在法线方向上进行挤出**，确保复杂曲面仍然符合拓扑要求。
- **更新 `nurbs_data` 并标记 `dirty` 以确保渲染和拓扑更新**。

### _rollback_to_pick_element

**概括描述**：

`_rollback_to_pick_element()` **用于在挤出操作失败或撤销时回滚到选择阶段**，清理所有临时数据，并恢复界面状态。

**详细描述**：

1. **清理所有缓存的 Mesh 数据**：
   - **如果当前处于 `EXTRUDE_FIXING` 步骤**，调用 `clear_all_cache_mesh_doc()` 清理所有与挤出相关的 Mesh 资源。

2. **重置核心变量**：
   - `m_pick_mesh_doc` 设置为 `nullptr`，表示当前未选中任何 Mesh 文档。
   - `clear_limits()` **重置挤出操作的移动限制**（如最大偏移量）。

3. **恢复界面状态**：
   - 获取当前 `View` 及其 `InferenceHelper`（推理工具）。
   - 设置推理工具的过滤模式为 `InferType::ALL_TYPE`，允许识别所有类型的元素。
   - **清空**：
     - `m_new_move_polygon_topo`（移动模式新生成的拓扑）
     - `m_new_add_polygon_topo`（新增模式新生成的拓扑）
     - `m_tmp_surfaces_guid`（用于存储临时 NURBS 曲面的 GUID）

4. **清除推理工具中的忽略项**：
   - `view->inferHelper()->clear_ignore();` 确保 **之前忽略的对象恢复可选状态**。

5. **重置挤出步骤**：
   - `m_extrude_step = ESketchExtrudeStep::PICK_ELEMENT;` 让控制器回到 **选择元素阶段**，等待用户进行新的选择。

**核心逻辑**：

- **回收所有临时创建的数据**，避免内存泄漏或无效对象残留。
- **确保 UI 状态回到选择模式**，用户可以重新选择要挤出的对象。
- **重置推理工具的行为**，允许检测所有可交互的元素。

# 功能说明

## 挤出功能说明

在计算机图形学中，挤出（Extrusion）是一种几何操作，它通过沿某个方向复制一个二维轮廓或面片，并生成新的连接面，从而形成三维结构。挤出常用于从2D形状生成3D物体，如从一个矩形挤出成立方体，从一个圆形挤出成圆柱体。

沿法线挤出是指使几何体沿着其法向量方向进行偏移，从而扩展表面。法向量（Normal）是垂直于面片的单位向量，表示该面朝向的方向。在挤出操作中，每个顶点都会沿其所在面的法向量移动一定的偏移量，从而形成新的面。

挤出的数学原理基于向量加法。如果给定一个顶点P的坐标(Px, Py, Pz)，其所在面的法向量N = (Nx, Ny, Nz)，以及挤出距离d，则挤出后的新顶点P'的坐标计算如下：

P' = P + d * N，即
P'x = Px + d * Nx
P'y = Py + d * Ny
P'z = Pz + d * Nz

这一计算方式确保了所有顶点都沿着法向量的方向均匀移动，从而保持面片的拓扑结构不变。在拓扑结构上，挤出会生成一组新的顶点，这些新顶点与原始顶点一起构成新的面，并在两者之间填充侧面，形成完整的封闭几何体。

挤出通常用于几何建模、有限元分析、建筑设计等场景。在3D建模软件（如Blender、Maya）中，挤出是基本操作，用户可以选择一个面，指定挤出方向和距离，软件会自动计算新顶点位置，并生成新的几何结构。

挤出计算的关键在于确定正确的法向量，并在此基础上应用向量位移运算。对于复杂几何体，还需要处理共面性的判断，以确保新几何体不会发生自交或扭曲。在后续部分，我们将分析项目中如何实现这一数学过程。

## 挤出功能设计

在 `Controller_Extrude_Polygon` 中，挤出（Extrude）是一种关键的几何编辑功能，它通过沿法向量（Normal）复制或移动多边形的顶点，生成新的几何结构。该功能直接影响 `GeoData`，包括更新顶点位置、修改面结构，并确保拓扑关系的正确性。挤出操作提供了两种模式：“新增模式（ADD）” 和 “移动模式（MOVE）”，分别用于创建新几何体和调整现有几何体的形状。

在“新增模式（ADD）”下，挤出操作会创建新的多边形，而不会改变原始面。用户选中某个面后，系统计算该面的法向量 `m_pick_polygon_normal`，然后基于 `offset` 偏移顶点位置，并生成新的面数据 `m_new_add_polygon_topo`，同时创建侧面将新旧面连接。最终，用户按下 `Enter` 触发 `commit_extrude_mesh()`，将 `m_add_inferring_mesh_doc` 合并到 `GeoData`，完成挤出操作。例如，用户在建模软件中选中立方体的顶部面，并向上挤出 2 个单位，结果是立方体的顶部面被复制到更高的位置，同时自动生成侧面连接新旧结构。

在“移动模式（MOVE）”下，挤出操作不会创建新几何体，而是直接移动原始面的位置，并调整相连的面以保持模型的连贯性。当用户拖动鼠标或输入数值时，系统调用 `create_move_operation_mesh(offset)` 计算新顶点位置，并实时更新 `m_new_move_polygon_topo` 存储的几何信息。提交后，系统会将 `m_move_inferring_mesh_doc` 应用到 `GeoData`，使修改生效。例如，用户选中立方体的顶部面并向上移动 2 个单位，整个立方体的高度增加，但不会生成额外的几何面。

在挤出操作过程中，系统使用推测网格（Inferring Mesh）进行预览，以提供流畅的用户体验。在 `EXTRUDE_FIXING` 状态下，`m_add_inferring_mesh_doc`（ADD 模式）或 `m_move_inferring_mesh_doc`（MOVE 模式）会根据鼠标移动或数值输入动态更新，确保用户能够实时看到挤出的效果。推测网格的核心计算包括 `create_add_operation_mesh(offset)` 和 `create_move_operation_mesh(offset)`，前者生成新的几何结构，后者直接移动已有几何体。此外，`prepare_add_mode_inferring_mesh()` 和 `prepare_move_mode_inferring_mesh()` 负责初始化推测网格，使其符合 `GeoData` 的拓扑结构，确保挤出过程的正确性。

挤出功能的交互流程包括多个步骤。首先，用户选中一个面，系统调用 `processPickPolygon()` 解析 `SketchPolygonPtr`，计算法向量 `m_pick_polygon_normal`，并存储到 `m_selected_polygon_topo`。接着，用户按下 `Enter` 或拖动鼠标进入 `EXTRUDE_BEGIN_FIXING` 状态，系统创建推测网格并允许实时调整 `offset`。偏移计算基于 `new_vertex = old_vertex + offset * normal`，其中 `offset` 由用户输入或鼠标拖动确定。在 `MOVE` 模式下，`m_new_move_polygon_topo` 记录顶点的新位置，而 `ADD` 模式下，`m_new_add_polygon_topo` 生成新的几何拓扑。用户按下 `Enter` 确认挤出后，`commit_extrude_mesh()` 负责更新 `GeoData`，将推测网格合并到正式网格，并清理 `m_add_inferring_mesh_doc` 或 `m_move_inferring_mesh_doc`。如果用户按下 `Escape`，`_rollback_to_pick_element()` 会恢复 `PICK_ELEMENT` 状态，取消当前挤出。

挤出功能涉及多个几何数据，包括顶点（Vertex）、边（Edge）、面（Face）和法向量（Normal）。其中，顶点决定了几何形态，边连接顶点形成面，面是封闭的几何区域，而法向量则用于确定挤出方向。在 `get_offseted_polygon_positions()` 计算偏移时，每个顶点都会沿 `m_pick_polygon_normal` 方向移动 `offset` 距离，生成新的顶点集合。推测网格（Inferring Mesh）在挤出过程中起到关键作用，在用户调整 `offset` 时，系统会不断更新 `m_add_inferring_mesh_doc` 或 `m_move_inferring_mesh_doc`，以便用户能够看到实时预览效果，并在 `EXTRUDE_FIXING` 状态下决定最终的挤出结果。

在挤出过程中，需要解决多个潜在问题。首先，防止挤出穿透其他面，避免几何体自交。系统调用 `need_flip_picked_normal()` 计算挤出方向，若挤出方向与其他几何体冲突，则自动调整 `offset` 范围。此外，`get_valid_coplane_rings()` 负责检查共面结构，确保挤出的新面不会破坏原始拓扑。其次，防止几何体变形，特别是在挤出过程中涉及多个环结构时。`offset_ring_positions()` 计算顶点的正确偏移，以确保几何形状不受破坏，`fix_inferring_mesh_doc()` 进一步修复拓扑问题，防止挤出后出现错误形状。最后，确保挤出后正确更新网格，`commit_extrude_mesh()` 负责合并推测网格到 `GeoData`，`clear_all_cache_mesh_doc()` 清理不再需要的网格数据，确保 `GeoData` 的拓扑结构正确更新。

综上，`Controller_Extrude_Polygon` 通过精确的法向量计算、推测网格预览、拓扑结构更新和交互优化，实现了稳定的挤出功能。用户可以自由选择 `ADD` 或 `MOVE` 模式，实时调整挤出参数，并确保几何体的完整性和拓扑正确性。

## 代码如何实现

`Controller_Extrude_ByNormal` 通过一系列步骤实现“沿法线挤出”功能，这包括用户交互、偏移计算、推测网格生成和最终提交网格数据。整个流程围绕 `mouse_down()`、`mouse_move()`、`commit_extrude_mesh()` 等函数展开，确保挤出操作的精确性和可控性。

首先，用户点击一个多边形面，`mouse_down()` 捕获该事件，并调用 `view->selector()->get_select_info()` 获取选中的几何信息。如果选中的对象是一个多边形，则 `_process_select_info(select_info)` 解析并存储必要的数据。此时，`processPickPolygon(picked_geo, ring)` 负责进一步处理几何数据，它计算 `m_pick_polygon_normal`，即当前选中面的法向量，并存储 `m_extrude_polygon_begin_position` 作为挤出起点。与此同时，`m_selected_polygon_topo` 记录选中多边形的拓扑结构，便于后续几何计算。为了确保挤出方向正确，`need_flip_picked_normal(picked_geo, pick_polygon)` 会分析当前法线方向是否合理，防止挤出导致面穿透其他几何体。如果一切正常，系统将 `m_extrude_step` 设为 `PICK_ELEMENT`，进入等待状态，直到用户提供进一步输入。

当用户拖动鼠标或输入数值调整挤出距离时，`mouse_move()` 负责动态计算 `offset` 并实时更新推测网格。偏移计算的核心在于 `offset = (m_hover_pos - m_extrude_polygon_begin_position) · m_pick_polygon_normal`，其中 `m_hover_pos` 是鼠标当前所在的位置，`m_pick_polygon_normal` 是选中多边形的法向量。通过计算鼠标在法向量方向上的投影距离，可以得到 `offset` 值，确保挤出操作严格遵循法线方向。随后，根据 `m_extrude_mode`，系统决定调用 `create_add_operation_mesh(offset)` 还是 `create_move_operation_mesh(offset)` 进行几何更新。在 `ADD` 模式下，`create_add_operation_mesh()` 复制原始面，生成新的顶点、侧面和拓扑数据，使挤出部分形成独立的几何体。而在 `MOVE` 模式下，`create_move_operation_mesh()` 直接调整选中面的顶点位置，使整个面沿法向量方向移动。`prepare_render(view)` 负责渲染这些变化，使用户可以在操作过程中看到挤出的实时预览。与此同时，用户还可以按 `Shift` 键触发 `key_down()`，从而调用 `switchMesh()` 切换 `ADD` 和 `MOVE` 模式。这一切确保用户能够灵活地调整挤出方式，适应不同的建模需求。

当用户对挤出结果满意并按下 `Enter` 时，`commit_extrude_mesh()` 负责将推测网格正式提交至 `GeoData`，完成最终的几何更新。如果当前模式是 `ADD`，则 `m_add_inferring_mesh_doc` 负责存储新增的面，并将其合并至 `GeoData`，同时 `m_splited_old_mesh_doc` 记录原始几何，以便在需要时回滚。而在 `MOVE` 模式下，`commit_extrude_mesh()` 直接更新 `m_pick_mesh_doc`，改变原始面的顶点位置，并调用 `fix_inferring_mesh_doc()` 修复可能出现的拓扑错误。由于 `MOVE` 模式涉及原始面的位置变动，因此 `fix_inferring_mesh_doc()` 需要检查 `m_move_inferring_mesh_doc` 是否存在重复顶点或冗余拓扑，并在必要时进行修正。完成几何提交后，`clear_all_cache_mesh_doc()` 负责删除 `m_add_inferring_mesh_doc` 和 `m_move_inferring_mesh_doc`，确保临时推测网格不会残留，`clear_inferring_mesh_doc()` 进一步清理未提交的数据，保证 `GeoData` 的完整性。

整个挤出过程的核心数学计算主要包括偏移量 `offset` 计算、顶点法线移动计算以及拓扑修正。在 `offset` 计算过程中，系统通过 `offset = (m_hover_pos - m_extrude_polygon_begin_position) · m_pick_polygon_normal` 计算鼠标在法向量方向上的位移，使挤出过程符合几何规则。在生成新几何时，`new_vertex = old_vertex + offset * m_pick_polygon_normal` 计算新顶点位置，并根据 `ADD` 或 `MOVE` 模式调整拓扑结构。在防止穿透问题上，`need_flip_picked_normal()` 通过分析 `m_selected_polygon_topo` 是否受到其他面限制，决定是否允许挤出或调整方向，以避免几何体发生错误交叉。

在代码实现层面，`switchMesh()` 允许 `ADD` 和 `MOVE` 之间无缝切换，它会隐藏当前模式的推测网格，同时计算并显示目标模式的推测网格，使用户能够更直观地操作挤出。而 `fix_inferring_mesh_doc()` 负责 `MOVE` 模式下的拓扑修复，它检查 `m_move_inferring_mesh_doc` 是否存在冗余点，并在发现问题时调整拓扑，以防止几何错误。此外，为了提高挤出稳定性，`get_valid_coplane_rings()` 计算相邻共面的环，确保新的拓扑结构不会破坏原有模型，`get_offseted_polygon_positions()` 统一所有顶点的挤出方向，防止挤出变形。

综上所述，`Controller_Extrude_ByNormal` 通过用户交互、偏移计算、推测网格、拓扑更新等一系列操作，实现了精准的“沿法线挤出”功能。`ADD` 模式用于创建新几何，而 `MOVE` 模式用于调整已有形态，结合实时计算 `offset` 和 `Inferring Mesh` 的动态渲染，使挤出操作直观、稳定且高效。

## 代码理解顺序

### 第一步：控制器的初始化和激活

首先，需要理解 `Controller_Extrude_ByNormal` 作为 `Controller_Edit` 的子类，在被用户选中进行挤出操作时如何初始化。

1. **`active(const SketchParamMap& props)`**
   - 当用户选择“挤出”工具时，`Controller_Extrude_ByNormal` 被激活。
   - 该函数设置鼠标指针样式、提示信息，并初始化 `m_extrude_step` 为 `PICK_ELEMENT`，表示等待用户选择一个多边形。
   - 该函数还清理了 `m_pick_mesh_doc`，确保不会受到上次挤出操作的影响。
2. **`deactive()`**
   - 当用户切换到其他工具或取消挤出模式时，该函数会被调用。
   - 其作用是清理所有缓存数据（包括推测网格 `m_add_inferring_mesh_doc` 和 `m_move_inferring_mesh_doc`），防止临时数据影响其他操作。

### 第二步：选取要挤出的多边形

当用户点击一个多边形进行选择时，系统需要解析选中的几何数据，并准备后续的挤出计算。

1. **`mouse_down(int button, int x, int y, bool ctrl, bool alt, bool shift)`**
   - 该函数在用户点击鼠标左键时触发。
   - 它会调用 `processPickPolygon(picked_geo, ring)` 来解析选中的多边形，并存储法向量 `m_pick_polygon_normal`。
   - 这一步完成后，`m_extrude_step` 进入 `EXTRUDE_BEGIN_FIXING`，表示多边形选取成功，等待用户输入挤出偏移量。
2. **`processPickPolygon(GeoData* picked_geo, SketchRingPtr ring)`**
   - 解析 `picked_geo` 以获取 `m_pick_polygon_normal`（当前选中面的法向量）。
   - 计算 `m_extrude_polygon_begin_position` 作为挤出起点。
   - 存储选中的多边形拓扑结构 `m_selected_polygon_topo`，确保在挤出过程中能够正确更新顶点、边和面。
3. **`need_flip_picked_normal(GeoData* geodata, SketchPolygonPtr pick_polygon)`**
   - 该函数判断 `m_pick_polygon_normal` 方向是否需要翻转，以确保挤出不会穿透其他面。
   - 如果 `m_pick_polygon_normal` 的正方向或负方向受到其他多边形限制，则修改 `m_valid_move_dir`，限制可用的挤出方向。

### 第三步：实时调整挤出偏移

当用户拖动鼠标或输入挤出数值时，系统需要计算挤出的偏移值 `offset`，并动态生成新的几何体。

1. **`mouse_move(int button, int x, int y, bool ctrl, bool alt, bool shift)`**
   - 计算鼠标的移动量 `m_hover_pos - m_extrude_polygon_begin_position`。
   - 计算偏移 `offset = (m_hover_pos - m_extrude_polygon_begin_position) · m_pick_polygon_normal`，确保挤出方向沿法向量。
   - 调用 `create_add_operation_mesh(offset)` 或 `create_move_operation_mesh(offset)`，根据 `m_extrude_mode` 生成推测网格 `Inferring Mesh`，让用户实时看到挤出效果。
2. **`create_add_operation_mesh(double offset)`**
   - 适用于 `ADD` 模式（创建新的几何体）。
   - 复制选中面的顶点，沿法向量 `m_pick_polygon_normal` 偏移 `offset`。
   - 生成新面的拓扑数据 `m_new_add_polygon_topo`，确保新面与原始面连接形成封闭几何体。
   - 更新 `m_add_inferring_mesh_doc`，用于显示推测网格。
3. **`create_move_operation_mesh(double offset)`**
   - 适用于 `MOVE` 模式（直接移动选中面）。
   - 计算 `offset` 的合法范围，防止面穿透其他多边形。
   - 直接调整 `m_new_move_polygon_topo` 内的顶点位置，使选中面沿 `m_pick_polygon_normal` 方向移动。
   - 更新 `m_move_inferring_mesh_doc`，提供推测挤出效果。

### 第四步：提交挤出

当用户按下 `Enter` 键确认挤出时，系统需要正式更新 `GeoData`，使挤出的几何体成为最终模型的一部分。

1. **`commit_extrude_mesh()`**
   - `ADD` 模式：
     - 将 `m_add_inferring_mesh_doc` 存入 `GeoData`，作为新的几何体。
     - 删除 `m_splited_old_mesh_doc`，确保不会残留错误拓扑数据。
   - `MOVE` 模式：
     - 直接更新 `m_pick_mesh_doc` 的顶点位置，使原始面永久变形。
     - 调用 `fix_inferring_mesh_doc()` 修复可能的拓扑问题。
2. **`fix_inferring_mesh_doc()`**
   - 适用于 `MOVE` 模式，修复因面移动导致的拓扑错误。
   - 检查 `m_move_inferring_mesh_doc` 是否存在重复顶点，并调整拓扑结构以确保几何体封闭。
3. **`clear_all_cache_mesh_doc()`**
   - 删除 `m_add_inferring_mesh_doc` 和 `m_move_inferring_mesh_doc`，释放内存。
   - 清空 `m_selected_polygon_topo`，避免残留数据影响下一次挤出操作。

### 第五步：取消或回滚挤出

如果用户按 `Escape` 取消挤出，或者在过程中出现错误，系统需要回滚到初始状态。

1. **`escape(const SketchParamMap& props)`**
   - 如果 `m_extrude_step == EXTRUDE_FIXING`，调用 `_rollback_to_pick_element()`，撤销当前挤出。
   - 否则，调用 `deactive()`，完全退出挤出模式。
2. **`_rollback_to_pick_element()`**
   - 清除 `m_pick_mesh_doc` 和 `m_selected_polygon_topo`，恢复到“选择多边形”状态。
   - 重新允许 `View` 选取新的多边形。

### 整体理解顺序

按照逻辑顺序理解代码：

1. `active()` → 初始化挤出工具，等待用户选择多边形。
2. `mouse_down()` → 解析选中的多边形，存储 `m_pick_polygon_normal`，进入 `EXTRUDE_BEGIN_FIXING`。
3. `mouse_move()` → 计算 `offset` 并动态更新推测网格（`create_add_operation_mesh()` 或 `create_move_operation_mesh()`）。
4. `commit_extrude_mesh()` → 用户按 `Enter` 确认挤出，更新 `GeoData` 并清理临时数据。
5. `escape()` → 用户按 `Escape` 取消挤出，调用 `_rollback_to_pick_element()` 回滚操作。

这样，就能清楚理解 `Controller_Extrude_ByNormal` 如何通过用户输入、数学计算、数据结构更新实现“沿法线挤出”功能。



