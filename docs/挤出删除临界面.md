## 需求整理

![image-20250221100747370](./assets/image-20250221100747370.png)

## 问题分析

```
对于这个类，我正在排查功能对应的代码，现在实现的功能是：假设立方体有A和B两个面相对应，在已经创建好的立方体的A面上再创建一个小矩形X，然后沿法线挤出X'，然后想沿着法线挤出挤出到B面，也就是X'到B面，中间部分会被掏空，而且矩形X'的四条边也会在B面上保留（或者理解为X'面会在B面上保留），我想问，这个操作流程，在代码中是怎样的，我关注的点就是末端面X'的保留，请深度思考，这部分逻辑在代码中是怎样体现的
```

```
我现在想新增的功能就是：对于新生成的顶面X'，检查这个X'面是否被已经存在的面包含，例如X'面与B面重合了，此时应该删除X'面，这部分应该如何实现？（关于一些现有的方法与变量，你可以参考Geodata和GeoDataUtil两个类，并且如果是要新增一些工具性的方法，那么要加在GeoDataUtil类中）
```

```
我的目的是：在最终生成所有的确定的几何体时，我要对新增的顶面判断是否有与其他已经存在的面重合的情况，重合的话（也就是被包含）就删除这个新的顶面，判断方法可以借助其他类已经写好的工具方法，但在Controller_Extrude_Polygon这个类里面应该怎么写呢？写在哪里呢？
```

```
我现在想新增的功能就是：在MOVE模式下，在合并最终结果之前，得到新生成的顶面信息，这一步应该怎么做呢（只需要告诉我在哪里插入什么代码即可），注意，这部分操作应该是放在倒数的位置的
```

```
（先不讨论代码，只讨论算法）我的问题：
1. 【目的是在最终生成确定的几何体时，对新增的顶面进行与其他已存在面的重合判断】这个是在移动模式的最终合并操作之前进行对吧？我想确认的是，对新顶面的判断与删除应该是倒数的步骤，因为这个步骤不能影响其他的功能，这个逻辑是绝对不能影响其他逻辑的
2. 为什么要进行【将现有多边形转换为 geos::geom::Geometry 对象】
```

```
这部分被// add包含的代码是我新增的，新增之前的代码是完全没问题的，我的逻辑体现在注释中，现在代码编译没问题，但是运行的时候崩溃，现在崩溃在GeoDataUtils::get().get_polygon_positions(m_pick_mesh_doc->geodata().get(),...，请你检查代码的实现，使用正确的实现方法来完成注释的功能
```

```
现在的问题是：第一次新建矩形面，然后对新建的矩形面进行挤出操作，打印：

然后就崩溃了
```

```
我现在想新增的功能就是：对于新生成的顶面，检查这个面是否被已经存在的面包含（也就是存在重合关系），若重合了，那么删除这个新增的顶面面，这部分应该如何实现？（这部分的逻辑我都用//add框起来了，其他的代码是没问题的，我需要你检查//add部分代码有没有什么问题）
```

```
检查函数是否实现了目标功能，代码是否有错（目前没有报错语法错误，但不知道逻辑是否有错）
```

```
现在这套逻辑满足了基本上所有的沿法线挤出的需求，但有一个没有满足，就是：假设现在有一个的立方体，有 A 和 B 两个面是相对的。在 A 面上创建一个较小的矩形 X，对矩形面 X 沿法线挤出，假设挤出到 X' 面，如果刚好到 B 面，那么此时就需要删除X'与B面重合的部分，也就是说，X' 面是不得保留的，你先不着急写代码，而是先思考，怎样的算法才能实现这个新需求
```

```
你的方案：（1）碰撞检测增强（在need_flip_picked_normal方法中补充距离检测）；（2）末端面标记机制（在MoveExtrudeLineCorrespondPrim结构体中新增字段）；（3）偏移量处理逻辑修改（在create_move_operation_mesh中添加接触判断）；（4）末端面清除逻辑（在commit_extrude_mesh的MOVE模式分支中添加）；（5）几何校验增强（在fix_inferring_mesh_doc中补充空面检测）。这一套算法，从逻辑上来说是可以的，但我认为这并不是最好的，因为从效果上来说，我只需要检测的是，在MOVE模式下，两个doc的重合部分的删除，只要有重合就删除重合部分，也就是这样只需要操作merge就行了，大致是这样想的，但具体的算法需要你思考，你先思考这种方案的可行性
```

```
我的意思是，在merge的时候删除重合的部分即可，例如X'与B重合了，那么就删除重合的部分（X'），但我不知道Controller_Extrude_Polygon类关于这部分的代码是不是需要补充很多，我是不是需要在MOVE模式下单独增加一个模式之类的，你觉得怎样来实现比较方便，请注意不要钻牛角尖，只要最后能实现“删除B面上的X'重合的部分”就是可以的算法，你也可以思考是否有更加方便的实现算法
```

```
既然这个方法是可行的，那么现在我们就来着手实现，请你阅读我提供的三个头文件，这里面包括了很多工具方法，请你思考，我的算法要实现的话，如何利用这些类的操作（如果我需要新增对几何的某种工具操作，那么可以加在GeoDataUtil.h中，因为GeoDataUtil是GeoData的友元类，可以访问GeoData的私有成员）
```

```
将代码语句的解释以及功能的解释都以注释的方式插入到这段代码中
```

```
先观察函数的功能，在现在的基础上，以插入注释的形式，结合实际的操作，在函数头部解释整体功能，在函数内部解释各段代码，形式是：
// 函数功能：...
void function()
{
	code; // ...
}
```

```
这段代码在“沿法线挤出”操作中有什么用呢？请结合实际功能解释函数功能
```

## 解决方案

### 方案一

```
在现有的挤出逻辑中，当从立方体的面A挤出矩形X到对面B时，X'面（即挤出的末端面）会被保留，但用户希望在这种情况下X'面被自动删除，实现完全挖空的效果。 首先，我需要理解现有的代码逻辑。用户提供的代码中，Controller_Extrude_Polygon.cpp处理挤出操作，特别是在commit_extrude_mesh函数中处理最终的网格合并。根据之前的分析，末端面X'是通过在临时文档中创建，并在合并时保留的。 用户的问题指出，当挤出到对面的面B时，X'面应该被删除。这可能是因为在这种情况下，X'面与面B重合，导致不需要保留，否则会留下一个多余的面。因此，我需要找到在代码中判断挤出是否到达对面面B的条件，并在该情况下删除X'面。 接下来，我需要查看代码中处理合并的部分，特别是在commit_extrude_mesh函数中的相关逻辑。该函数处理两种模式：ADD和MOVE。在MOVE模式下，会合并m_move_inferring_mesh_doc到原始文档中。可能在合并前需要检查挤出是否到达限制，即是否碰到了对面的面B。 查看之前的代码，发现在create_move_operation_mesh函数中，有限制offset的逻辑，通过m_positive_offset_limit和m_negative_offset_limit来限制偏移量，这些限制可能是在prepare_move_mode_inferring_mesh中通过计算相邻面之间的距离得到的。如果offset达到了这些限制值，说明挤出面接触到了其他面，此时应删除末端面。 因此，解决方案可能是在合并操作前，检查当前的offset是否达到了限制值，如果是，则在合并时删除X'面。具体来说，在commit_extrude_mesh函数中，当检测到offset达到限制时，需要找到X'面对应的多边形并将其删除。 此外，在fix_inferring_mesh_doc函数中，处理临时文档的合并时，可能已经有跳过X'面的逻辑（如通过ring的key判断）。但如果需要删除X'面，可能需要在此处添加条件判断，当达到限制时，不保留该面。 需要考虑的步骤： 1. 在commit_extrude_mesh中，判断当前挤出是否达到了正或负的限制值。 2. 如果达到限制值，执行额外的步骤来删除末端面X'。 3. 在合并临时文档到原始文档前，删除对应的面。 需要检查代码中如何存储X'面的信息。在move模式下，X'面的拓扑信息存储在m_new_move_polygon_topo_arr中，可能在合并时需要检查这些面是否需要被删除。 可能的代码修改点： - 在commit_extrude_mesh的MOVE模式处理部分，检查offset是否达到限制，如果是，则遍历m_new_move_polygon_topo_arr中的面，并在合并前将其从m_move_inferring_mesh_doc中删除。 需要确保删除操作在合并前进行，并且不影响其他几何结构。此外，需要考虑如何准确判断是否到达对面面B，可能需要通过碰撞检测或距离计算来确认。 总结：关键点在于检测挤出是否到达对面面，并在合并时删除末端面。这可能需要修改commit_extrude_mesh函数，添加条件判断和删除操作。
```

### 方案二

```
用户希望当挤压生成的新面X'与现有面B重合时，自动删除X'。用户提到之前的方案可能过于复杂，想寻找更简便的方法。 首先，我需要理解当前代码的结构。用户提供的代码中，commit_extrude_mesh函数负责提交挤压操作后的网格。在MOVE模式下，合并m_move_inferring_mesh_doc到m_pick_mesh_doc后，需要检测并删除重合的面。 用户之前的方案是在merge之后遍历新面并进行射线检测，但可能存在性能问题或实现复杂性。我需要考虑是否有更高效的方式。 可能的思路是利用现有的几何库（如GEOS）进行面的相交检测。当合并后，可以比较新生成的面与现有面是否重合，如果重合则删除新面。这可能在合并前或合并后进行。 另一个考虑是，在生成新面时就预测是否会与现有面重合，从而避免生成多余的面。但可能难以准确预测，尤其是在复杂几何情况下。 回顾代码，发现merge操作后，m_pick_mesh_doc会包含合并后的几何数据。可以在merge之后，对新添加的面进行遍历，检查每个面是否与现有面重合，若重合则删除。 但如何高效识别新添加的面？可能在merge过程中标记新生成的面，或者在合并后通过比较差异来获取新增的面。 或者，在merge之后，对整个模型的几何进行全局检查，找出重合的面并删除。但这种方法可能在性能上有问题，尤其是模型复杂时。 用户希望简便实现，可能采用在merge之后，针对特定新面进行快速检测。例如，在MOVE模式下，新生成的面是m_new_move_polygon_topo_arr，可以在合并后检查这些面是否与现有面重合。 改进步骤可能包括： 1. 在commit_extrude_mesh的MOVE模式处理中，合并后遍历新生成的面。 2. 对每个新面，使用几何库检测是否与现有面重合。 3. 若重合，则从m_pick_mesh_doc中删除该面。 这需要访问m_pick_mesh_doc的GeoData，并实现面重合检测逻辑。利用现有的GEOS库函数进行面包含判断可能更高效。 此外，需要考虑面的朝向和容差，避免误删。例如，使用面的法线方向和几何包含关系来判断是否重合。 总结，最直接的修改是在合并后，对新面进行遍历，使用几何检测删除重合部分。这样不需要修改太多现有流程，且实现相对简单。
```

### 方案三

先梳理一下在 `commit_extrude_mesh` 函数中添加新功能的详细算法逻辑。目的是在最终生成确定的几何体时，对新增的顶面进行与其他已存在面的重合判断，如果新增顶面被其他已存在的面包含，则删除该新增顶面。

1. **初始化和准备阶段**：
   - 获取当前聚焦的视图和场景文档。
   - 清除隐藏的对象。
2. **处理网格文档**：
   - 如果选中的网格文档存在：
     - 添加模式：
       - 如果存在分割的旧网格文档，将其合并到选中的网格文档中，并删除分割的旧网格文档。
       - 如果存在添加推断网格文档，将其合并到选中的网格文档中，并删除添加推断网格文档。
       - 如果存在移动推断网格文档，删除移动推断网格文档。
     - 移动模式：
       - 如果存在移动推断网格文档，修复推断网格文档，并将其合并到选中的网格文档中，删除移动推断网格文档。
       - 如果合并失败，停用控制器并输出错误信息。
       - 生成新顶面：
         - 在生成新顶面之后，添加检测逻辑。对新顶面进行与其他已存在面的重合判断和删除操作应该是在移动模式的最终合并操作之前执行。这个步骤应当作为倒数的步骤，确保它不会影响其他功能。具体来说，这个检查应该在所有临时网格已经生成并准备提交到选中的网格文档之前执行。这样做的原因：不影响其他逻辑：此逻辑是为了确保新生成的几何体不会与现有的几何体发生冲突或冗余，因此它不应该干扰其他的功能或逻辑。保证数据一致性：如果在合并前就进行了重合判断，可以避免不必要的几何体被添加到模型中，从而保持模型的数据一致性和简洁性。
         - 获取新增顶面的几何数据。
         - 将新顶面转换为 `geos::geom::Geometry` 对象。 将现有多边形转换为 `geos::geom::Geometry` 对象的主要目的是为了利用 GEOS 库提供的几何运算功能来进行高效的几何关系判断。
         - 遍历现有的多边形检测包含关系：
           - 遍历所有已存在的多边形，获取现有多边形的位置数据。
           - 将现有多边形转换为 `geos::geom::Geometry` 对象。
           - 使用 `geos_util::is_contain` 方法判断新顶面是否被现有多边形包含。
           - 如果判断出新增顶面被包含，则删除该顶面。
         - 释放新顶面和现有多边形的几何对象。
       - 如果存在分割的旧网格文档，删除分割的旧网格文档。
       - 如果存在添加推断网格文档，删除添加推断网格文档。
3. **处理NURBS文档**：
   - 如果选中的NURBS文档存在：
     - 获取NURBS数据。
     - 遍历临时表面的GUID。
     - 如果临时表面是代数曲面或封闭曲面，移除临时表面，并将其转换为修剪曲面添加到NURBS数据中。
     - 标记NURBS文档为脏数据。
4. **重置挤出步骤和清除相关参数**：
   - 重置挤出步骤为选择元素。
   - 清除挤出操作的限制参数。
   - 清除新的移动多边形拓扑。
   - 清除新的添加多边形拓扑。
   - 清除临时表面的GUID。

```cpp
void GeoDataUtils::get_polygon_positions(GeoData* geodata, SketchPolygonPtr polygon, std::vector<std::vector<nous::pos_t>>& out_pos_arr)
{
    std::vector<SketchPointPtr> exring_points_arr;
    std::vector<nous::pos_t>& exring_pos_arr = out_pos_arr.emplace_back();
    geodata->get_element_points(polygon->ring, exring_points_arr);
    for(auto one_point: exring_points_arr)
    {
        nous::vec3 point_origin = geodata->get_point_position(one_point);
        exring_pos_arr.emplace_back(point_origin);
    }

    for(const auto& inner_ring: polygon->inner_rings)
    {
        std::vector<SketchPointPtr> inring_points_arr;
        geodata->get_element_points(inner_ring, inring_points_arr);
        std::vector<nous::pos_t>& inring_pos_arr = out_pos_arr.emplace_back();
        for(auto one_point: inring_points_arr)
        {
            nous::vec3 point_origin = geodata->get_point_position(one_point);
            inring_pos_arr.emplace_back(point_origin);
        }
    }
}

void GeoDataUtils::get_polygon_positions(GeoData* geodata, const std::vector<std::vector<SketchPointPtr>>& polygon,
                                         std::vector<std::vector<nous::pos_t>>& out_pos_arr)
{
    for(int i = 0; i < polygon.size(); ++i)
    {
        std::vector<nous::pos_t>& ring_pos_arr = out_pos_arr.emplace_back();
        for(auto one_point: polygon[i])
        {
            if(!one_point->point->vertex_ptr())
            {
                continue;
            }
            nous::vec3 point_origin = geodata->get_point_position(one_point);
            ring_pos_arr.emplace_back(point_origin);
        }
    }
}
```

